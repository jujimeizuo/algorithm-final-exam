{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6c5f\u5357\u5927\u5b66 2023 \u5e74\u7b97\u6cd5\u8bbe\u8ba1\u4e0e\u5206\u6790\u671f\u672b\u590d\u4e60 \u00b6 Table of Contents \u00b6 \u9012\u5f52\u4e0e\u5206\u6cbb \u52a8\u6001\u89c4\u5212 \u8d2a\u5fc3 \u56de\u6eaf\u6cd5 \u5206\u652f\u9650\u754c\u6cd5 \u968f\u673a\u7b97\u6cd5 \u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41 \u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5","title":"\u4e3b\u9875"},{"location":"#2023","text":"","title":"\u6c5f\u5357\u5927\u5b66 2023 \u5e74\u7b97\u6cd5\u8bbe\u8ba1\u4e0e\u5206\u6790\u671f\u672b\u590d\u4e60"},{"location":"#table-of-contents","text":"\u9012\u5f52\u4e0e\u5206\u6cbb \u52a8\u6001\u89c4\u5212 \u8d2a\u5fc3 \u56de\u6eaf\u6cd5 \u5206\u652f\u9650\u754c\u6cd5 \u968f\u673a\u7b97\u6cd5 \u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41 \u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5","title":"Table of Contents"},{"location":"1/","text":"\u9012\u5f52\u4e0e\u5206\u6cbb \u00b6 \u4e8c\u5206\u641c\u7d22 \u5927\u6574\u6570\u7684\u4e58\u6cd5 Strassen \u77e9\u9635\u4e58\u6cd5 \u68cb\u76d8\u8986\u76d6 \u5408\u5e76\u6392\u5e8f \u5feb\u901f\u6392\u5e8f \u7ebf\u6027\u65f6\u95f4\u9009\u62e9 \u6700\u63a5\u8fd1\u70b9\u5bf9\u95ee\u9898 \u5faa\u73af\u8d5b\u65e5\u7a0b\u8868","title":"\u9012\u5f52\u4e0e\u5206\u6cbb"},{"location":"1/#_1","text":"\u4e8c\u5206\u641c\u7d22 \u5927\u6574\u6570\u7684\u4e58\u6cd5 Strassen \u77e9\u9635\u4e58\u6cd5 \u68cb\u76d8\u8986\u76d6 \u5408\u5e76\u6392\u5e8f \u5feb\u901f\u6392\u5e8f \u7ebf\u6027\u65f6\u95f4\u9009\u62e9 \u6700\u63a5\u8fd1\u70b9\u5bf9\u95ee\u9898 \u5faa\u73af\u8d5b\u65e5\u7a0b\u8868","title":"\u9012\u5f52\u4e0e\u5206\u6cbb"},{"location":"1/1/","text":"template < typename T > int BinarySearch ( const std :: vector < T >& arr , T target ) { int l = 0 , r = arr . size () - 1 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == target ) { return mid ; } else if ( arr [ mid ] < target ) { l = mid + 1 ; } else { r = mid - 1 ; } } return -1 ; }","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"1/2/","text":"std :: vector < int > solve ( std :: string X , std :: string Y ) { std :: vector < int > result ( 255 , 0 ); std :: function < void ( std :: string , std :: string , int ) > multiply = [ & ]( std :: string s , std :: string t , int pos ) { int n = ( int ) s . size (), m = ( int ) t . size (); if ( n == 0 m == 0 ) { // \u4f4d\u6570\u4e3a0\u65f6 return ; } else if ( n == 1 && m == 1 ) { // \u9012\u5f52\u5230\u5f53\u524d\u6570\u7ec4s\u548ct\u7684\u4f4d\u6570\u5168\u4e3a1\u65f6 result [ pos ] += ( s [ 0 ] - '0' ) * ( t [ 0 ] - '0' ); return ; } else { // \u5f53\u6570\u7ec4s\u548ct\u7684\u4f4d\u6570\u81f3\u5c11\u6709\u4e00\u4e2a\u4e0d\u4e3a1\u65f6 int n1 = n / 2 ; // n1\u4e3aB\u7684\u4f4d\u6570\uff0cB\u5c5e\u4e8e\u4f4e\u4f4d\u7684\u90a3\u4e00\u90e8\u5206 int n2 = n - n1 ; // n2\u4e3aA\u7684\u4f4d\u6570\uff0cA\u5c5e\u4e8e\u9ad8\u4f4d\u7684\u90a3\u4e00\u90e8\u5206 int m1 = m / 2 ; // m1\u4e3aD\u7684\u4f4d\u6570\uff0cD\u5c5e\u4e8e\u4f4e\u4f4d\u7684\u90a3\u4e00\u90e8\u5206 int m2 = m - m1 ; // m2\u4e3aD\u7684\u4f4d\u6570\uff0cC\u5c5e\u4e8e\u9ad8\u4f4d\u7684\u90a3\u4e00\u90e8\u5206 std :: string A = s . substr ( 0 , n2 ); // \u83b7\u53d6s\u7684\u9ad8\u4f4d\u90e8\u5206A std :: string B = s . substr ( n2 ); // \u83b7\u53d6s\u7684\u4f4e\u4f4d\u90e8\u5206B std :: string C = t . substr ( 0 , m2 ); // \u83b7\u53d6t\u7684\u9ad8\u4f4d\u90e8\u5206C std :: string D = t . substr ( m2 ); // \u83b7\u53d6t\u7684\u4f4e\u4f4d\u90e8\u5206D multiply ( A , C , pos + n1 + m1 ); // AC,\u5728result[pos+n1+m1]\u7684\u4f4d\u7f6e\u5b58\u50a8AC\uff0c\u4e5f\u662f\u8bf4\u504f\u79fbpos+n1+m1\u4f4d\uff0cpos\u521d\u59cb\u5316\u4e3a0 multiply ( B , C , pos + m1 ); // BC,\u504f\u79fbpos+m1\u4f4d multiply ( A , D , pos + n1 ); // AD,\u504f\u79fbpos+1\u4f4d multiply ( B , D , pos ); // BD,\u504f\u79fbpos\u4f4d } }; multiply ( X , Y , 0 ); int len = ( int ) X . size () + ( int ) Y . size (); for ( int i = 0 ; i <= len ; i ++ ) { int now = result [ i ] % 10 ; int bit1 = result [ i ] / 10 % 10 ; int bit2 = result [ i ] / 100 ; result [ i ] = now ; result [ i + 1 ] += bit1 ; result [ i + 2 ] += bit2 ; } while ( result . back () == 0 ) { result . pop_back (); } return result ; }","title":"\u5927\u6574\u6570\u7684\u4e58\u6cd5"},{"location":"1/3/","text":"std :: vector < std :: vector < int >> strassen ( std :: vector < std :: vector < int > > & A , std :: vector < std :: vector < int > > & B ) { int n = A . size (); std :: vector < std :: vector < int >> R ( n , std :: vector < int > ( n )); if ( n <= 2 ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { R [ i ][ j ] = 0 ; for ( int k = 0 ; k < n ; k ++ ) R [ i ][ j ] += A [ i ][ k ] * B [ k ][ j ]; } } return R ; } else { int m = n / 2 ; std :: vector < std :: vector < int >> A11 ( m , std :: vector < int > ( m )), A12 ( m , std :: vector < int > ( m )), A21 ( m , std :: vector < int > ( m )), A22 ( m , std :: vector < int > ( m )); std :: vector < std :: vector < int >> B11 ( m , std :: vector < int > ( m )), B12 ( m , std :: vector < int > ( m )), B21 ( m , std :: vector < int > ( m )), B22 ( m , std :: vector < int > ( m )); // \u4ee5\u4e0b\u6b65\u9aa4\u5206\u89e3\u8f93\u5165\u77e9\u9635\u4e3a\u5c0f\u77e9\u9635 // ... // Strassen's recursive calls and additions to compute the 7 products // and then calculate the 4 quadrants of the resulting matrix // ... return R ; } }","title":"Strassen \u77e9\u9635\u4e58\u6cd5"},{"location":"1/4/","text":"int tile = 0 ; void ChessBoard ( int tr , int tc , int dr , int dc , int size ) { if ( size == 1 ) { return ; } int t = tile ++ ; s = size / 2 ; if ( dr < tr + s && dc < tc + s ) { ChessBoard ( tr , tc , dr , dc , s ); } else { board [ tr + s - 1 ][ tc + s - 1 ] = t ; ChessBoard ( tr , tc , tr + s - 1 , tc + s - 1 , s ); } if ( dr < tr + s && dc >= tc + s ) { ChessBoard ( tr , tc + s , dr , dc , s ); } else { board [ tr + s - 1 ][ tc + s ] = t ; ChessBoard ( tr , tc + s , tr + s - 1 , tc + s , s ); } if ( dr >= tr + s && dc < tc + s ) { ChessBoard ( tr + s , tc , dr , dc , s ); } else { board [ tr + s ][ tc + s - 1 ] = t ; ChessBoard ( tr + s , tc , tr + s , tc + s - 1 , s ); } if ( dr >= tr + s && dc >= tc + s ) { ChessBoard ( tr + s , tc + s , dr , dc , s ); } else { board [ tr + s ][ tc + s ] = t ; ChessBoard ( tr + s , tc + s , tr + s , tc + s , s ); } }","title":"\u68cb\u76d8\u8986\u76d6"},{"location":"1/5/","text":"std :: vector < int > temp ; void merge ( std :: vector < int >& arr , int l , int mid , int r ) { std :: copy ( arr . begin () + l , arr . begin () + r , temp . begin () + l ); int p = l , q = mid ; for ( int i = l ; i < r ; i ++ ) { if ( q >= r || ( p < mid && arr [ p ] < arr [ q ])) { temp [ i ] = arr [ p ++ ]; } else { temp [ i ] = arr [ q ++ ]; } } std :: copy ( temp . begin () + l , temp . begin () + r , arr . begin () + l ); } void mergeSort ( std :: vector < int >& arr , int l , int r ) { if ( r - l == 1 ) { return ; } int mid = ( l + r ) / 2 ; mergeSort ( arr , l , mid ); mergeSort ( arr , mid , r ); merge ( arr , l , mid , r ); } void mergeSort ( std :: vector < int >& arr ) { temp . resize ( arr . size ()); mergeSort ( arr , 0 , ( int ) arr . size ()); }","title":"\u5408\u5e76\u6392\u5e8f"},{"location":"1/6/","text":"int partition ( std :: vector < int >& arr , int l , int r ) { int pivot = arr [ l ]; while ( l < r ) { while ( l < r && arr [ r ] >= pivot ) r -- ; arr [ l ] = arr [ r ]; while ( l < r && arr [ l ] <= pivot ) l ++ ; arr [ r ] = arr [ l ]; } arr [ l ] = pivot ; return l ; } void quickSort ( std :: vector < int >& arr , int l , int r ) { if ( l < r ) { // random select pivot, can reduce the probability of the worst case complexity int i = rand () % ( r - l + 1 ) + l ; std :: swap ( arr [ l ], arr [ i ]); int pos = partition ( arr , l , r ); quickSort ( arr , l , pos - 1 ); quickSort ( arr , pos + 1 , r ); } } void quickSort ( std :: vector < int >& arr ) { srand (( unsigned ) time ( NULL )); quickSort ( arr , 0 , ( int ) arr . size () - 1 ); }","title":"\u5feb\u901f\u6392\u5e8f"},{"location":"1/7/","text":"","title":"\u7ebf\u6027\u65f6\u95f4\u9009\u62e9"},{"location":"1/8/","text":"typedef long long ll ; const int N = 1e5 + 10 ; struct node { ll x [ 2 ]; } a [ N ], b [ N ]; int now , n ; ll ans ; map < pair < ll , ll > , int > mp ; bool cmp ( node a , node b ) { return a . x [ now ] < b . x [ now ]; } ll sqr ( int x ) { return ( ll ) x * x ; } ll dis ( node a , node b ) { return sqr ( a . x [ 0 ] - b . x [ 0 ]) + sqr ( a . x [ 1 ] - b . x [ 1 ]); } void build ( int l , int r , int d ) { if ( l >= r ) return ; int m = ( l + r ) >> 1 ; now = d ; nth_element ( a + l , a + m , a + r , cmp ); build ( l , m , d ^ 1 ); build ( m + 1 , r , d ^ 1 ); } void query ( int l , int r , int d , node p ) { if ( l >= r ) return ; int m = ( l + r ) >> 1 ; int ql = l , qr = m ; ll res = dis ( a [ m ], p ); if ( ans == 0 || res && ans > res ) ans = res ; if ( p . x [ d ] > a [ m ]. x [ d ]) ql = m + 1 , qr = r ; query ( ql , qr , d ^ 1 , p ); if ( ans > sqr ( a [ m ]. x [ d ] - p . x [ d ])) query ( l + m - ql + 1 , m + r - qr , d ^ 1 , p ); } void solve () { scanf ( \"%d\" , & n ); ll sum = 5e18 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%lld %lld\" , & a [ i ]. x [ 0 ], & a [ i ]. x [ 1 ]); if ( mp [{ a [ i ]. x [ 0 ], a [ i ]. x [ 1 ]}]) sum = 0 ; else mp [{ a [ i ]. x [ 0 ], a [ i ]. x [ 1 ]}] ++ ; b [ i ] = a [ i ]; } build ( 0 , n , 0 ); for ( int i = 0 ; i < n ; i ++ ) { ans = 0 ; query ( 0 , n , 0 , b [ i ]); sum = min ( ans , sum ); } printf ( \"%.4lf \\n \" , sqrt ( 1.0 * sum )); }","title":"\u6700\u63a5\u8fd1\u70b9\u5bf9\u95ee\u9898"},{"location":"1/9/","text":"void Table ( int k , int ** a ) { int n = 1 ; for ( int i = 0 ; i < k ; ++ i ) { n *= 2 ; } for ( int i = 1 ; i <= n ; ++ i ) { a [ 1 ][ i ] = i ; } int m = 1 ; for ( int s = 1 ; s <= k ; s ++ ) { n /= 2 ; for ( int t = 1 ; t <= n ; t ++ ) { for ( int i = m + 1 ; i <= m * 2 ; i ++ ) { for ( int j = m + 1 ; j <= m * 2 ; j ++ ) { a [ s ][ i * n + j ] = a [ s - 1 ][ t * m + i ] * m * 2 + a [ s - 1 ][ t * m + j ]; } m *= 2 ; } } } }","title":"\u5faa\u73af\u8d5b\u65e5\u7a0b\u8868"},{"location":"2/","text":"\u52a8\u6001\u89c4\u5212 \u00b6 \u77e9\u9635\u8fde\u4e58\u95ee\u9898 \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 \u6700\u5927\u5b50\u6bb5\u548c \u51f8\u591a\u8fb9\u5f62\u6700\u4f18\u4e09\u89d2\u5256\u5206 \u591a\u8fb9\u5f62\u6e38\u620f \u56fe\u50cf\u538b\u7f29 \u7535\u8def\u5e03\u7ebf \u6d41\u6c34\u4f5c\u4e1a\u8c03\u5ea6 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u4f18\u4e8c\u53c9\u641c\u7d22\u6811","title":"\u52a8\u6001\u89c4\u5212"},{"location":"2/#_1","text":"\u77e9\u9635\u8fde\u4e58\u95ee\u9898 \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 \u6700\u5927\u5b50\u6bb5\u548c \u51f8\u591a\u8fb9\u5f62\u6700\u4f18\u4e09\u89d2\u5256\u5206 \u591a\u8fb9\u5f62\u6e38\u620f \u56fe\u50cf\u538b\u7f29 \u7535\u8def\u5e03\u7ebf \u6d41\u6c34\u4f5c\u4e1a\u8c03\u5ea6 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u4f18\u4e8c\u53c9\u641c\u7d22\u6811","title":"\u52a8\u6001\u89c4\u5212"},{"location":"2/1/","text":"void MatrixChain ( int * p , int n , int ** m , int ** s ) { for ( int i = 1 ; i <= n ; ++ i ) { m [ i ][ i ] = 0 ; } for ( int r = 2 ; r <= n ; ++ r ) { for ( int i = 1 ; i <= n - r + 1 ; ++ i ) { int j = i + r - 1 ; m [ i ][ j ] = m [ i + 1 ][ j ] + p [ i - 1 ] * p [ i ] * p [ j ]; s [ i ][ j ] = i ; for ( int k = i + 1 ; k < j ; ++ k ) { int t = m [ i ][ k ] + m [ k + 1 ][ j ] + p [ i - 1 ] * p [ k ] * p [ j ]; if ( t < m [ i ][ j ]) { m [ i ][ j ] = t ; s [ i ][ j ] = k ; } } } } } void Traceback ( int i , int j , int ** s ) { if ( i == j ) return ; Traceback ( i , s [ i ][ j ], s ); Traceback ( s [ i ][ j ] + 1 , j , s ); cout << \"Multiply A\" << i << \",\" << s [ i ][ j ]; cout << \"and A\" << ( s [ i ][ j ] + 1 ) << \",\" << j << endl ; }","title":"\u77e9\u9635\u8fde\u4e58\u95ee\u9898"},{"location":"2/10/","text":"void OptimalBinarySearchTree ( int a , int b , int n , int ** m , int ** s , int ** w ) { for ( int i = 1 ; i <= n ; i ++ ) { w [ i + 1 ][ i ] = a [ i ]; m [ i + 1 ][ i ] = 0 ; } for ( int r = 0 ; r < n ; r ++ ) { for ( int i = 1 ; i <= n - r ; i ++ ) { int j = i + r ; w [ i ][ j ] = w [ i ][ j - 1 ] + a [ j ] + b [ j ]; m [ i ][ j ] = m [ i + 1 ][ j ]; s [ i ][ j ] = i ; for ( int k = i + 1 ; k <= j ; k ++ ) { int t = m [ i ][ k - 1 ] + m [ k + 1 ][ j ]; if ( t < m [ i ][ j ]) { m [ i ][ j ] = t ; s [ i ][ j ] = k ; } } m [ i ][ j ] += w [ i ][ j ]; } } }","title":"\u6700\u4f18\u4e8c\u53c9\u641c\u7d22\u6811"},{"location":"2/2/","text":"void LCS ( const std :: string & s , std :: string & t , int ** c , int ** b ) { int m = s . size (); int n = t . size (); for ( int i = 1 ; i <= m ; ++ i ) { c [ i ][ 0 ] = 0 ; } for ( int j = 1 ; j <= n ; ++ j ) { c [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( s [ i - 1 ] == t [ j - 1 ]) { c [ i ][ j ] = c [ i - 1 ][ j - 1 ] + 1 ; b [ i ][ j ] = 1 ; } else if ( c [ i - 1 ][ j ] >= c [ i ][ j - 1 ]) { c [ i ][ j ] = c [ i - 1 ][ j ]; b [ i ][ j ] = 2 ; } else { c [ i ][ j ] = c [ i ][ j - 1 ]; b [ i ][ j ] = 3 ; } } } } void LCS ( int i , int j , const std :: string & s , int ** b ) { if ( i == 0 || j == 0 ) { return ; } if ( b [ i ][ j ] == 1 ) { LCS ( i - 1 , j - 1 , s , b ); std :: cout << s [ i - 1 ]; } else if ( b [ i ][ j ] == 2 ) { LCS ( i - 1 , j , s , b ); } else { LCS ( i , j - 1 , s , b ); } }","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"2/3/","text":"1d int MaxSum ( const std :: vector < int >& a ) { int n = a . size (); int sum = 0 , b = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( b > 0 ) { b += a [ i ]; } else { b = a [ i ]; } sum = std :: max ( sum , b ); } return sum ; } 2d int MaxSum ( const std :: vector < std :: vector < int >>& a ) { int m = a . size (), n = a [ 0 ]. size (); int sum = 0 ; for ( int i = 0 ; i < m ; ++ i ) { std :: vector < int > b ( n ); for ( int j = i ; j < n ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { b [ k ] += a [ j ][ k ]; } sum = std :: max ( sum , MaxSum ( t )); } } return sum ; }","title":"\u6700\u5927\u5b50\u6bb5\u548c"},{"location":"2/4/","text":"\u4e0e\u77e9\u9635\u8fde\u4e58\u76f8\u540c\u3002","title":"\u51f8\u591a\u8fb9\u5f62\u6700\u4f18\u4e09\u89d2\u5256\u5206"},{"location":"2/5/","text":"","title":"\u591a\u8fb9\u5f62\u6e38\u620f"},{"location":"2/6/","text":"int length ( int x ) { int len = 0 ; while ( x ) { len ++ ; x /= 2 ; } return len ; } void Compress ( int n , int p [], int s [], int l [], int b []) { int Lmax = 256 , header = 11 ; s [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { b [ i ] = length ( p [ i ]); int bmax = b [ i ]; s [ i ] = s [ i - 1 ] + bmax ; l [ i ] = 1 ; for ( int j = 2 ; j <= i && j <= Lmax ; j ++ ) { if ( bmax < b [ i - j + 1 ]) { bmax = b [ i - j + 1 ]; } if ( s [ i ] > s [ i - j ] + j * bmax ) { s [ i ] = s [ i - j ] + j * bmax ; l [ i ] = j ; } } s [ i ] += header ; } }","title":"\u56fe\u50cf\u538b\u7f29"},{"location":"2/7/","text":"std :: vector < std :: vector < int >> MNS ( std :: vector < int >& C ) { int n = C . size (); std :: vector < std :: vector < int >> s ( n + 1 , std :: vector < int > ( n + 1 , 0 )); for ( int j = 0 ; j < C [ 1 ]; j ++ ) { s [ 1 ][ j ] = 0 ; } for ( int j = C [ 1 ]; j <= n ; j ++ ) { s [ 1 ][ j ] = 1 ; } for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < C [ i ]; j ++ ) { s [ i ][ j ] = s [ i - 1 ][ j ]; } for ( int j = C [ i ]; j <= n ; j ++ ) { s [ i ][ j ] = std :: max ( s [ i - 1 ][ j ], s [ i - 1 ][ C [ i ] - 1 ] + 1 ); } } s [ n ][ n ] = std :: max ( s [ n - 1 ][ n ], s [ n - 1 ][ C [ n ] - 1 ] + 1 ); } std :: vector < int > Traceback ( std :: vector < int >& C , std :: vector < std :: vector < int >>& s ) { int n = C . size (); std :: vector < int > Net ; for ( int i = n ; i > 1 ; i -- ) { if ( s [ i ][ j ] != s [ i - 1 ][ j ]) { Net . push_back ( i ); j = C [ i ] - 1 ; } if ( j >= C [ 1 ]) { Net . push_back ( 1 ); } } }","title":"\u7535\u8def\u5e03\u7ebf"},{"location":"2/8/","text":"int FlowShop ( int n , int a , int b , int c ) { class Jobtype { public : int key , index ; bool job ; int operator <= ( Jobtype a ) const { return key <= a . key ; } }; Jobtype * d = new Jobtype [ n ]; for ( int i = 0 ; i < n ; i ++ ) { d [ i ]. key = a [ i ] > b [ i ] ? b [ i ] : a [ i ]; d [ i ]. job = a [ i ] <= b [ i ]; d [ i ]. index = i ; } std :: sort ( d , d + n ); int j = 0 , k = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ]. job ) { c [ j ++ ] = d [ i ]. index ; } else { c [ k -- ] = d [ i ]. index ; } } j = a [ c [ 0 ]]; k = j + b [ c [ 0 ]]; for ( int i = 1 ; i < n ; i ++ ) { j += a [ c [ i ]]; k = j > k ? j + b [ c [ i ]] : k + b [ c [ i ]]; } delete [] d ; return k ; }","title":"\u6d41\u6c34\u4f5c\u4e1a\u8c03\u5ea6"},{"location":"2/9/","text":"template < typename T > T knapSack ( const std :: vector < int >& v , const std :: vector < T >& w , int V ) { int n = ( int ) v . size (); std :: vector < T > dp ( V + 1 ); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = V ; j >= v [ i ]; j -- ) { dp [ j ] = std :: max ( dp [ j ], dp [ j - v [ i ]] + w [ i ]); } } return dp . back (); }","title":"0-1 \u80cc\u5305\u95ee\u9898"},{"location":"3/","text":"\u8d2a\u5fc3 \u00b6 \u6d3b\u52a8\u5b89\u6392\u95ee\u9898 \u6700\u4f18\u88c5\u8f7d \u54c8\u592b\u66fc\u7f16\u7801 \u5355\u6e90\u6700\u77ed\u8def\u5f84 \u6700\u5c0f\u751f\u6210\u6811 \u591a\u673a\u8c03\u5ea6\u95ee\u9898","title":"\u8d2a\u5fc3"},{"location":"3/#_1","text":"\u6d3b\u52a8\u5b89\u6392\u95ee\u9898 \u6700\u4f18\u88c5\u8f7d \u54c8\u592b\u66fc\u7f16\u7801 \u5355\u6e90\u6700\u77ed\u8def\u5f84 \u6700\u5c0f\u751f\u6210\u6811 \u591a\u673a\u8c03\u5ea6\u95ee\u9898","title":"\u8d2a\u5fc3"},{"location":"3/1/","text":"template < typename T > void GreedySelector ( int n , T s [], T f [], bool A []) { // sort by finish time A [ 1 ] = true ; int j = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( s [ i ] >= f [ j ]) { A [ i ] = true ; j = i ; } else { A [ i ] = false ; } } }","title":"\u6d3b\u52a8\u5b89\u6392\u95ee\u9898"},{"location":"3/2/","text":"std :: vector < int > Loading ( const std :: vector < int >& w , int V ) { int n = w . size (); std :: vector < int > order ( n ); std :: iota ( order . begin (), order . end (), 0 ); std :: sort ( order . begin (), order . end (), [ & w ]( int i , int j ) { return w [ i ] < w [ j ]; }); std :: vector < int > x ( n ); for ( int i = 0 ; i < n && w [ order [ i ]] <= c ; i ++ ) { x [ w [ order [ i ]]] = 1 ; c -= w [ order [ i ]]; } return x ; }","title":"\u6700\u4f18\u88c5\u8f7d"},{"location":"3/3/","text":"class HuffmanTreeNode { public : char data ; // stores character int freq ; // stores of frequency of the character HuffmanTreeNode * left ; // left child of the current node HuffmanTreeNode * right ; // right child of the current node HuffmanTreeNode ( char character , int frequency ) : data ( character ), freq ( frequency ), left ( nullptr ), right ( nullptr ) {} }; // custom comparator class class Compare { public : bool operator ()( HuffmanTreeNode * lhs , HuffmanTreeNode * rhs ) { // defining priority on the basis of frequency return lhs -> freq > rhs -> freq ; } }; // generate Huffman Encoding Tree HuffmanTreeNode * generateTree ( std :: vector < char >& data , std :: vector < int >& freq ) { int size = ( int ) data . size (); std :: priority_queue < HuffmanTreeNode * , std :: vector < HuffmanTreeNode *> , Compare > pq ; for ( int i = 0 ; i < size ; i ++ ) { HuffmanTreeNode * newNode = new HuffmanTreeNode ( data [ i ], freq [ i ]); pq . push ( newNode ); } while ( pq . size () != 1 ) { HuffmanTreeNode * left = pq . top (); pq . pop (); HuffmanTreeNode * right = pq . top (); pq . pop (); HuffmanTreeNode * node = new HuffmanTreeNode ( '$' , left -> freq + right -> freq ); node -> left = left ; node -> right = right ; pq . push ( node ); } return pq . top (); } // print the huffman code for each character void printCodes ( HuffmanTreeNode * root , std :: string & code , std :: vector < std :: pair < char , std :: string >>& codes ) { if ( root -> left ) { code += '0' ; printCodes ( root -> left , code , codes ); code . pop_back (); } if ( root -> right ) { code += '1' ; printCodes ( root -> right , code , codes ); code . pop_back (); } // if this is a leaf node, then we print root -> data if ( ! root -> left && ! root -> right ) { codes . emplace_back ( root -> data , code ); } } std :: vector < std :: pair < char , std :: string >> HuffmanCodes ( HuffmanTreeNode * root ) { std :: vector < std :: pair < char , std :: string >> codes ; std :: string code ( \"\" ); printCodes ( root , code , codes ); return codes ; } int getWPL ( HuffmanTreeNode * root , int len ) { if ( root == nullptr ) { return 0 ; } if ( root -> left == nullptr && root -> right == nullptr ) { return root -> freq * len ; } int lwpl = getWPL ( root -> left , len + 1 ); int rwpl = getWPL ( root -> right , len + 1 ); return lwpl + rwpl ; }","title":"\u54c8\u592b\u66fc\u7f16\u7801"},{"location":"3/4/","text":"Graph template < typename T > class graph { public : struct edge { int from ; int to ; T cost ; }; const int n ; std :: vector < edge > edges ; std :: vector < std :: vector < int >> g ; graph ( int _n ) : n ( _n ), g ( _n ) {} virtual int add ( int from , int to , T cost ) = 0 ; }; template < typename T > class digraph : public graph < T > { public : using graph < T >:: edges ; using graph < T >:: g ; using graph < T >:: n ; digraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); int id = ( int ) edges . size (); g [ from ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } digraph < T > reverse () const { digraph < T > rev ( n ); for ( auto & e : edges ) { rev . add ( e . to , e . from , e . cost ); } return rev ; } }; template < typename T > class undigraph : public graph < T > { public : using graph < T >:: edges ; using graph < T >:: g ; using graph < T >:: n ; undigraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); int id = ( int ) edges . size (); g [ from ]. push_back ( id ); g [ to ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } }; dijkstra template < typename T > std :: vector < T > dijkstra ( const graph < T >& g , int st ) { assert ( 0 <= st && st < g . n ); std :: vector < T > dist ( g . n , std :: numeric_limits < T >:: max ()); std :: priority_queue < std :: pair < T , int > , std :: vector < std :: pair < T , int >> , std :: greater < std :: pair < T , int >> > q ; dist [ st ] = 0 ; q . emplace ( dist [ st ], st ); while ( ! q . empty ()) { T expected = q . top (). first ; int u = q . top (). second ; q . pop (); if ( dist [ u ] != expected ) { continue ; } for ( int id : g . g [ u ]) { auto & e = g . edges [ id ]; int to = e . from ^ e . to ^ u ; if ( dist [ to ] > dist [ u ] + e . cost ) { dist [ to ] = dist [ u ] + e . cost ; q . emplace ( dist [ to ], to ); } } } return dist ; // returns numeric_limits<T>::max() if there's no path }","title":"\u5355\u6e90\u6700\u77ed\u8def\u5f84"},{"location":"3/5/","text":"Graph template < typename T > class graph { public : struct edge { int from ; int to ; T cost ; }; const int n ; std :: vector < edge > edges ; std :: vector < std :: vector < int >> g ; graph ( int _n ) : n ( _n ), g ( _n ) {} virtual int add ( int from , int to , T cost ) = 0 ; }; template < typename T > class digraph : public graph < T > { public : using graph < T >:: edges ; using graph < T >:: g ; using graph < T >:: n ; digraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); int id = ( int ) edges . size (); g [ from ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } digraph < T > reverse () const { digraph < T > rev ( n ); for ( auto & e : edges ) { rev . add ( e . to , e . from , e . cost ); } return rev ; } }; template < typename T > class undigraph : public graph < T > { public : using graph < T >:: edges ; using graph < T >:: g ; using graph < T >:: n ; undigraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); int id = ( int ) edges . size (); g [ from ]. push_back ( id ); g [ to ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } }; kruskal struct DSU { std :: vector < int > f , siz ; int components = 0 ; DSU ( int n ) : f ( n ), siz ( n , 1 ), components ( n ) { std :: iota ( f . begin (), f . end (), 0 ); } inline int find ( int x ) { while ( x != f [ x ]) { x = f [ x ] = f [ f [ x ]]; } return x ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } bool merge ( int x , int y ) { x = find ( x ); y = find ( y ); if ( x == y ) { return false ; } siz [ x ] += siz [ y ]; f [ y ] = x ; components -- ; return true ; } int size ( int x ) { return siz [ find ( x )]; } int total_components () { return components ; } }; template < typename T > std :: vector < int > kruskal ( const undigraph < T > & g , T & ans ) { std :: vector < int > order ( g . edges . size ()); iota ( order . begin (), order . end (), 0 ); sort ( order . begin (), order . end (), [ & g ]( int a , int b ) { return g . edges [ a ]. cost < g . edges [ b ]. cost ; }); DSU d ( g . n ); std :: vector < int > ans_list ; ans = 0 ; for ( int id : order ) { auto & e = g . edges [ id ]; if ( ! d . same ( e . from , e . to )) { d . merge ( e . from , e . to ); ans_list . push_back ( id ); ans += e . cost ; } } return ans_list ; // returns edge ids of minimum \"spanning\" forest } prim template < typename T > bool prim ( const undigraph < T > & g , T & ans ) { std :: vector < bool > vis ( g . n ); std :: priority_queue < std :: pair < T , int > , std :: vector < std :: pair < T , int >> , std :: greater < std :: pair < T , int >> > q ; q . push ({ 0 , 0 }); int cnt = 0 ; ans = 0 ; while ( ! q . empty () && cnt < g . n ) { T expected = q . top (). first ; int u = q . top (). second ; q . pop (); if ( vis [ u ]) continue ; vis [ u ] = true ; ans += expected ; cnt ++ ; for ( int id : g . g [ u ]) { auto & e = g . edges [ id ]; int to = e . from ^ e . to ^ u ; if ( ! vis [ to ]) { q . push ({ e . cost , to }); } } } return cnt == g . n ; // returns false if there's not connected }","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"3/6/","text":"class JobNode { friend void Greedy ( JobNode * , int , int ); friend void main ( void ); public : operator int () const { return time ; } private : int ID , time ; }; class MachineNode { friend void Greedy ( JobNode * , int , int ); public : operator int () const { return avail ; } private : int ID , avail ; }; template < class Type > void Greedy ( Type a [], int n , int m ) { if ( n <= m ) { std :: cout << \"\u4e3a\u6bcf\u4e00\u4e2a\u4f5c\u4e1a\u5206\u914d\u4e00\u4e2a\u673a\u5668\" << std :: endl ; return ; } std :: sort ( a , a + n ); MinHeap < MachineNode > H ( m ); MachineNode x ; for ( int i = 0 ; i < m ; i ++ ) { x . avail = 0 ; x . ID = i + 1 ; H . Insert ( x ); } for ( int i = 0 ; i < n ; i ++ ) { H . DeleteMin ( x ); cout << \"\u5c06\u673a\u5668\" << x . ID << \"\u4ece\" << x . avail << \"\u5230\" << x . avail + a [ i ]. time << \"\u7684\u65f6\u95f4\u6bb5\u5206\u914d\u7ed9\u4f5c\u4e1a\" << a [ i ]. ID << endl ; x . avail += a [ i ]. time ; H . Insert ( x ); } }","title":"\u591a\u673a\u8c03\u5ea6\u95ee\u9898"},{"location":"4/","text":"\u56de\u6eaf\u6cd5 \u00b6 \u88c5\u8f7d\u95ee\u9898 \u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6 \u7b26\u53f7\u4e09\u89d2\u5f62\u95ee\u9898 n \u7687\u540e\u95ee\u9898 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u5927\u56e2\u95ee\u9898 \u56fe\u7684 m \u7740\u8272\u95ee\u9898 \u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898 \u5706\u6392\u5217\u95ee\u9898 \u7535\u8def\u677f\u6392\u5217\u95ee\u9898 \u8fde\u7eed\u90ae\u8d44\u95ee\u9898","title":"\u56de\u6eaf\u6cd5"},{"location":"4/#_1","text":"\u88c5\u8f7d\u95ee\u9898 \u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6 \u7b26\u53f7\u4e09\u89d2\u5f62\u95ee\u9898 n \u7687\u540e\u95ee\u9898 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u5927\u56e2\u95ee\u9898 \u56fe\u7684 m \u7740\u8272\u95ee\u9898 \u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898 \u5706\u6392\u5217\u95ee\u9898 \u7535\u8def\u677f\u6392\u5217\u95ee\u9898 \u8fde\u7eed\u90ae\u8d44\u95ee\u9898","title":"\u56de\u6eaf\u6cd5"},{"location":"4/1/","text":"","title":"\u88c5\u8f7d\u95ee\u9898"},{"location":"4/10/","text":"","title":"\u7535\u8def\u677f\u6392\u5217\u95ee\u9898"},{"location":"4/11/","text":"","title":"\u8fde\u7eed\u90ae\u8d44\u95ee\u9898"},{"location":"4/2/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6"},{"location":"4/2/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"4/3/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u7b26\u53f7\u4e09\u89d2\u5f62\u95ee\u9898"},{"location":"4/3/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"4/4/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"n \u7687\u540e\u95ee\u9898"},{"location":"4/4/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"4/5/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"0-1 \u80cc\u5305\u95ee\u9898"},{"location":"4/5/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"4/6/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6700\u5927\u56e2\u95ee\u9898"},{"location":"4/6/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"4/7/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u56fe\u7684 m \u7740\u8272\u95ee\u9898"},{"location":"4/7/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"4/8/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898"},{"location":"4/8/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"4/9/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u5706\u6392\u5217\u95ee\u9898"},{"location":"4/9/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"5/","text":"\u5206\u652f\u9650\u754c\u6cd5 \u00b6 \u5355\u6e90\u6700\u77ed\u8def\u5f84\u95ee\u9898 \u88c5\u8f7d\u95ee\u9898 \u5e03\u7ebf\u95ee\u9898 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u5927\u56e2\u95ee\u9898 \u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898 \u7535\u8def\u677f\u6392\u5217\u95ee\u9898 \u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6","title":"\u5206\u652f\u9650\u754c\u6cd5"},{"location":"5/#_1","text":"\u5355\u6e90\u6700\u77ed\u8def\u5f84\u95ee\u9898 \u88c5\u8f7d\u95ee\u9898 \u5e03\u7ebf\u95ee\u9898 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u5927\u56e2\u95ee\u9898 \u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898 \u7535\u8def\u677f\u6392\u5217\u95ee\u9898 \u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6","title":"\u5206\u652f\u9650\u754c\u6cd5"},{"location":"5/1/","text":"","title":"\u5355\u6e90\u6700\u77ed\u8def\u5f84\u95ee\u9898"},{"location":"5/2/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u88c5\u8f7d\u95ee\u9898"},{"location":"5/2/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"5/3/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u5e03\u7ebf\u95ee\u9898"},{"location":"5/3/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"5/4/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"0-1 \u80cc\u5305\u95ee\u9898"},{"location":"5/4/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"5/5/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6700\u5927\u56e2\u95ee\u9898"},{"location":"5/5/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"5/6/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898"},{"location":"5/6/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"5/7/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u7535\u8def\u677f\u6392\u5217\u95ee\u9898"},{"location":"5/7/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"5/8/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6"},{"location":"5/8/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"6/","text":"\u968f\u673a\u7b97\u6cd5 \u00b6 \u968f\u673a\u6570 \u6570\u503c\u968f\u673a\u5316\u7b97\u6cd5 \u820d\u4f0d\u5fb7\u7b97\u6cd5 \u62c9\u65af\u7ef4\u52a0\u65af\u7b97\u6cd5 \u8499\u7279\u5361\u7f57\u7b97\u6cd5","title":"\u968f\u673a\u7b97\u6cd5"},{"location":"6/#_1","text":"\u968f\u673a\u6570 \u6570\u503c\u968f\u673a\u5316\u7b97\u6cd5 \u820d\u4f0d\u5fb7\u7b97\u6cd5 \u62c9\u65af\u7ef4\u52a0\u65af\u7b97\u6cd5 \u8499\u7279\u5361\u7f57\u7b97\u6cd5","title":"\u968f\u673a\u7b97\u6cd5"},{"location":"6/1/","text":"","title":"\u968f\u673a\u6570"},{"location":"6/2/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6570\u503c\u968f\u673a\u5316\u7b97\u6cd5"},{"location":"6/2/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"6/3/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u820d\u4f0d\u5fb7\u7b97\u6cd5"},{"location":"6/3/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"6/4/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u62c9\u65af\u7ef4\u52a0\u65af\u7b97\u6cd5"},{"location":"6/4/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"6/5/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u8499\u7279\u5361\u7f57\u7b97\u6cd5"},{"location":"6/5/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"7/","text":"\u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41 \u00b6 \u7ebf\u6027\u89c4\u5212\u95ee\u9898\u548c\u5355\u7eaf\u5f62\u6cd5\u7b97\u6cd5 \u6700\u5927\u7f51\u7edc\u6d41\u95ee\u9898 \u6700\u5c0f\u8d39\u7528\u6d41\u95ee\u9898","title":"\u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41"},{"location":"7/#_1","text":"\u7ebf\u6027\u89c4\u5212\u95ee\u9898\u548c\u5355\u7eaf\u5f62\u6cd5\u7b97\u6cd5 \u6700\u5927\u7f51\u7edc\u6d41\u95ee\u9898 \u6700\u5c0f\u8d39\u7528\u6d41\u95ee\u9898","title":"\u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41"},{"location":"7/1/","text":"","title":"\u7ebf\u6027\u89c4\u5212\u95ee\u9898\u548c\u5355\u7eaf\u5f62\u6cd5\u7b97\u6cd5"},{"location":"7/2/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6700\u5927\u7f51\u7edc\u6d41\u95ee\u9898"},{"location":"7/2/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"7/3/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6700\u5c0f\u8d39\u7528\u6d41\u95ee\u9898"},{"location":"7/3/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"8/","text":"\u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5 \u00b6 \u5b50\u4e32\u641c\u7d22\u7b97\u6cd5 \u540e\u7f00\u6570\u7ec4\u4e0e\u6700\u957f\u516c\u5171\u5b50\u4e32 \u5e8f\u5217\u6bd4\u8f83\u7b97\u6cd5","title":"\u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5"},{"location":"8/#_1","text":"\u5b50\u4e32\u641c\u7d22\u7b97\u6cd5 \u540e\u7f00\u6570\u7ec4\u4e0e\u6700\u957f\u516c\u5171\u5b50\u4e32 \u5e8f\u5217\u6bd4\u8f83\u7b97\u6cd5","title":"\u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5"},{"location":"8/1/","text":"","title":"\u5b50\u4e32\u641c\u7d22\u7b97\u6cd5"},{"location":"8/2/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u540e\u7f00\u6570\u7ec4\u4e0e\u6700\u957f\u516c\u5171\u5b50\u4e32"},{"location":"8/2/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"8/3/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u5e8f\u5217\u6bd4\u8f83\u7b97\u6cd5"},{"location":"8/3/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"}]}