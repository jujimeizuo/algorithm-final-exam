{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6c5f\u5357\u5927\u5b66 2023 \u5e74\u7b97\u6cd5\u8bbe\u8ba1\u4e0e\u5206\u6790\u671f\u672b\u590d\u4e60 \u00b6 Table of Contents \u00b6 \u9012\u5f52\u4e0e\u5206\u6cbb \u52a8\u6001\u89c4\u5212 \u8d2a\u5fc3 \u56de\u6eaf\u6cd5 \u5206\u652f\u9650\u754c\u6cd5 \u968f\u673a\u7b97\u6cd5 \u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41 \u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5","title":"\u4e3b\u9875"},{"location":"#2023","text":"","title":"\u6c5f\u5357\u5927\u5b66 2023 \u5e74\u7b97\u6cd5\u8bbe\u8ba1\u4e0e\u5206\u6790\u671f\u672b\u590d\u4e60"},{"location":"#table-of-contents","text":"\u9012\u5f52\u4e0e\u5206\u6cbb \u52a8\u6001\u89c4\u5212 \u8d2a\u5fc3 \u56de\u6eaf\u6cd5 \u5206\u652f\u9650\u754c\u6cd5 \u968f\u673a\u7b97\u6cd5 \u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41 \u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5","title":"Table of Contents"},{"location":"1/","text":"\u9012\u5f52\u4e0e\u5206\u6cbb \u00b6 \u4e8c\u5206\u641c\u7d22 \u5927\u6574\u6570\u7684\u4e58\u6cd5 Strassen \u77e9\u9635\u4e58\u6cd5 \u68cb\u76d8\u8986\u76d6 \u5408\u5e76\u6392\u5e8f \u5feb\u901f\u6392\u5e8f \u7ebf\u6027\u65f6\u95f4\u9009\u62e9 \u6700\u63a5\u8fd1\u70b9\u5bf9\u95ee\u9898 \u5faa\u73af\u8d5b\u65e5\u7a0b\u8868","title":"\u9012\u5f52\u4e0e\u5206\u6cbb"},{"location":"1/#_1","text":"\u4e8c\u5206\u641c\u7d22 \u5927\u6574\u6570\u7684\u4e58\u6cd5 Strassen \u77e9\u9635\u4e58\u6cd5 \u68cb\u76d8\u8986\u76d6 \u5408\u5e76\u6392\u5e8f \u5feb\u901f\u6392\u5e8f \u7ebf\u6027\u65f6\u95f4\u9009\u62e9 \u6700\u63a5\u8fd1\u70b9\u5bf9\u95ee\u9898 \u5faa\u73af\u8d5b\u65e5\u7a0b\u8868","title":"\u9012\u5f52\u4e0e\u5206\u6cbb"},{"location":"1/1/","text":"template < typename T > int BinarySearch ( const std :: vector < T >& arr , T target ) { int l = 0 , r = arr . size () - 1 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == target ) { return mid ; } else if ( arr [ mid ] < target ) { l = mid + 1 ; } else { r = mid - 1 ; } } return -1 ; }","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"1/2/","text":"std :: vector < int > solve ( std :: string X , std :: string Y ) { std :: vector < int > result ( 255 , 0 ); std :: function < void ( std :: string , std :: string , int ) > multiply = [ & ]( std :: string s , std :: string t , int pos ) { int n = ( int ) s . size (), m = ( int ) t . size (); if ( n == 0 m == 0 ) { // \u4f4d\u6570\u4e3a0\u65f6 return ; } else if ( n == 1 && m == 1 ) { // \u9012\u5f52\u5230\u5f53\u524d\u6570\u7ec4s\u548ct\u7684\u4f4d\u6570\u5168\u4e3a1\u65f6 result [ pos ] += ( s [ 0 ] - '0' ) * ( t [ 0 ] - '0' ); return ; } else { // \u5f53\u6570\u7ec4s\u548ct\u7684\u4f4d\u6570\u81f3\u5c11\u6709\u4e00\u4e2a\u4e0d\u4e3a1\u65f6 int n1 = n / 2 ; // n1\u4e3aB\u7684\u4f4d\u6570\uff0cB\u5c5e\u4e8e\u4f4e\u4f4d\u7684\u90a3\u4e00\u90e8\u5206 int n2 = n - n1 ; // n2\u4e3aA\u7684\u4f4d\u6570\uff0cA\u5c5e\u4e8e\u9ad8\u4f4d\u7684\u90a3\u4e00\u90e8\u5206 int m1 = m / 2 ; // m1\u4e3aD\u7684\u4f4d\u6570\uff0cD\u5c5e\u4e8e\u4f4e\u4f4d\u7684\u90a3\u4e00\u90e8\u5206 int m2 = m - m1 ; // m2\u4e3aD\u7684\u4f4d\u6570\uff0cC\u5c5e\u4e8e\u9ad8\u4f4d\u7684\u90a3\u4e00\u90e8\u5206 std :: string A = s . substr ( 0 , n2 ); // \u83b7\u53d6s\u7684\u9ad8\u4f4d\u90e8\u5206A std :: string B = s . substr ( n2 ); // \u83b7\u53d6s\u7684\u4f4e\u4f4d\u90e8\u5206B std :: string C = t . substr ( 0 , m2 ); // \u83b7\u53d6t\u7684\u9ad8\u4f4d\u90e8\u5206C std :: string D = t . substr ( m2 ); // \u83b7\u53d6t\u7684\u4f4e\u4f4d\u90e8\u5206D multiply ( A , C , pos + n1 + m1 ); // AC,\u5728result[pos+n1+m1]\u7684\u4f4d\u7f6e\u5b58\u50a8AC\uff0c\u4e5f\u662f\u8bf4\u504f\u79fbpos+n1+m1\u4f4d\uff0cpos\u521d\u59cb\u5316\u4e3a0 multiply ( B , C , pos + m1 ); // BC,\u504f\u79fbpos+m1\u4f4d multiply ( A , D , pos + n1 ); // AD,\u504f\u79fbpos+1\u4f4d multiply ( B , D , pos ); // BD,\u504f\u79fbpos\u4f4d } }; multiply ( X , Y , 0 ); int len = ( int ) X . size () + ( int ) Y . size (); for ( int i = 0 ; i <= len ; i ++ ) { int now = result [ i ] % 10 ; int bit1 = result [ i ] / 10 % 10 ; int bit2 = result [ i ] / 100 ; result [ i ] = now ; result [ i + 1 ] += bit1 ; result [ i + 2 ] += bit2 ; } while ( result . back () == 0 ) { result . pop_back (); } return result ; }","title":"\u5927\u6574\u6570\u7684\u4e58\u6cd5"},{"location":"1/3/","text":"std :: vector < std :: vector < int >> strassen ( std :: vector < std :: vector < int > > & A , std :: vector < std :: vector < int > > & B ) { int n = A . size (); std :: vector < std :: vector < int >> R ( n , std :: vector < int > ( n )); if ( n <= 2 ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { R [ i ][ j ] = 0 ; for ( int k = 0 ; k < n ; k ++ ) R [ i ][ j ] += A [ i ][ k ] * B [ k ][ j ]; } } return R ; } else { int m = n / 2 ; std :: vector < std :: vector < int >> A11 ( m , std :: vector < int > ( m )), A12 ( m , std :: vector < int > ( m )), A21 ( m , std :: vector < int > ( m )), A22 ( m , std :: vector < int > ( m )); std :: vector < std :: vector < int >> B11 ( m , std :: vector < int > ( m )), B12 ( m , std :: vector < int > ( m )), B21 ( m , std :: vector < int > ( m )), B22 ( m , std :: vector < int > ( m )); // \u4ee5\u4e0b\u6b65\u9aa4\u5206\u89e3\u8f93\u5165\u77e9\u9635\u4e3a\u5c0f\u77e9\u9635 // ... // Strassen's recursive calls and additions to compute the 7 products // and then calculate the 4 quadrants of the resulting matrix // ... return R ; } }","title":"Strassen \u77e9\u9635\u4e58\u6cd5"},{"location":"1/4/","text":"int tile = 0 ; void ChessBoard ( int tr , int tc , int dr , int dc , int size ) { if ( size == 1 ) { return ; } int t = tile ++ ; s = size / 2 ; if ( dr < tr + s && dc < tc + s ) { ChessBoard ( tr , tc , dr , dc , s ); } else { board [ tr + s - 1 ][ tc + s - 1 ] = t ; ChessBoard ( tr , tc , tr + s - 1 , tc + s - 1 , s ); } if ( dr < tr + s && dc >= tc + s ) { ChessBoard ( tr , tc + s , dr , dc , s ); } else { board [ tr + s - 1 ][ tc + s ] = t ; ChessBoard ( tr , tc + s , tr + s - 1 , tc + s , s ); } if ( dr >= tr + s && dc < tc + s ) { ChessBoard ( tr + s , tc , dr , dc , s ); } else { board [ tr + s ][ tc + s - 1 ] = t ; ChessBoard ( tr + s , tc , tr + s , tc + s - 1 , s ); } if ( dr >= tr + s && dc >= tc + s ) { ChessBoard ( tr + s , tc + s , dr , dc , s ); } else { board [ tr + s ][ tc + s ] = t ; ChessBoard ( tr + s , tc + s , tr + s , tc + s , s ); } }","title":"\u68cb\u76d8\u8986\u76d6"},{"location":"1/5/","text":"std :: vector < int > temp ; void merge ( std :: vector < int >& arr , int l , int mid , int r ) { std :: copy ( arr . begin () + l , arr . begin () + r , temp . begin () + l ); int p = l , q = mid ; for ( int i = l ; i < r ; i ++ ) { if ( q >= r || ( p < mid && arr [ p ] < arr [ q ])) { temp [ i ] = arr [ p ++ ]; } else { temp [ i ] = arr [ q ++ ]; } } std :: copy ( temp . begin () + l , temp . begin () + r , arr . begin () + l ); } void mergeSort ( std :: vector < int >& arr , int l , int r ) { if ( r - l == 1 ) { return ; } int mid = ( l + r ) / 2 ; mergeSort ( arr , l , mid ); mergeSort ( arr , mid , r ); merge ( arr , l , mid , r ); } void mergeSort ( std :: vector < int >& arr ) { temp . resize ( arr . size ()); mergeSort ( arr , 0 , ( int ) arr . size ()); }","title":"\u5408\u5e76\u6392\u5e8f"},{"location":"1/6/","text":"int partition ( std :: vector < int >& arr , int l , int r ) { int pivot = arr [ l ]; while ( l < r ) { while ( l < r && arr [ r ] >= pivot ) r -- ; arr [ l ] = arr [ r ]; while ( l < r && arr [ l ] <= pivot ) l ++ ; arr [ r ] = arr [ l ]; } arr [ l ] = pivot ; return l ; } void quickSort ( std :: vector < int >& arr , int l , int r ) { if ( l < r ) { // random select pivot, can reduce the probability of the worst case complexity int i = rand () % ( r - l + 1 ) + l ; std :: swap ( arr [ l ], arr [ i ]); int pos = partition ( arr , l , r ); quickSort ( arr , l , pos - 1 ); quickSort ( arr , pos + 1 , r ); } } void quickSort ( std :: vector < int >& arr ) { srand (( unsigned ) time ( NULL )); quickSort ( arr , 0 , ( int ) arr . size () - 1 ); }","title":"\u5feb\u901f\u6392\u5e8f"},{"location":"1/7/","text":"","title":"\u7ebf\u6027\u65f6\u95f4\u9009\u62e9"},{"location":"1/8/","text":"typedef long long ll ; const int N = 1e5 + 10 ; struct node { ll x [ 2 ]; } a [ N ], b [ N ]; int now , n ; ll ans ; map < pair < ll , ll > , int > mp ; bool cmp ( node a , node b ) { return a . x [ now ] < b . x [ now ]; } ll sqr ( int x ) { return ( ll ) x * x ; } ll dis ( node a , node b ) { return sqr ( a . x [ 0 ] - b . x [ 0 ]) + sqr ( a . x [ 1 ] - b . x [ 1 ]); } void build ( int l , int r , int d ) { if ( l >= r ) return ; int m = ( l + r ) >> 1 ; now = d ; nth_element ( a + l , a + m , a + r , cmp ); build ( l , m , d ^ 1 ); build ( m + 1 , r , d ^ 1 ); } void query ( int l , int r , int d , node p ) { if ( l >= r ) return ; int m = ( l + r ) >> 1 ; int ql = l , qr = m ; ll res = dis ( a [ m ], p ); if ( ans == 0 || res && ans > res ) ans = res ; if ( p . x [ d ] > a [ m ]. x [ d ]) ql = m + 1 , qr = r ; query ( ql , qr , d ^ 1 , p ); if ( ans > sqr ( a [ m ]. x [ d ] - p . x [ d ])) query ( l + m - ql + 1 , m + r - qr , d ^ 1 , p ); } void solve () { scanf ( \"%d\" , & n ); ll sum = 5e18 ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( \"%lld %lld\" , & a [ i ]. x [ 0 ], & a [ i ]. x [ 1 ]); if ( mp [{ a [ i ]. x [ 0 ], a [ i ]. x [ 1 ]}]) sum = 0 ; else mp [{ a [ i ]. x [ 0 ], a [ i ]. x [ 1 ]}] ++ ; b [ i ] = a [ i ]; } build ( 0 , n , 0 ); for ( int i = 0 ; i < n ; i ++ ) { ans = 0 ; query ( 0 , n , 0 , b [ i ]); sum = min ( ans , sum ); } printf ( \"%.4lf \\n \" , sqrt ( 1.0 * sum )); }","title":"\u6700\u63a5\u8fd1\u70b9\u5bf9\u95ee\u9898"},{"location":"1/9/","text":"void Table ( int k , int ** a ) { int n = 1 ; for ( int i = 0 ; i < k ; ++ i ) { n *= 2 ; } for ( int i = 1 ; i <= n ; ++ i ) { a [ 1 ][ i ] = i ; } int m = 1 ; for ( int s = 1 ; s <= k ; s ++ ) { n /= 2 ; for ( int t = 1 ; t <= n ; t ++ ) { for ( int i = m + 1 ; i <= m * 2 ; i ++ ) { for ( int j = m + 1 ; j <= m * 2 ; j ++ ) { a [ s ][ i * n + j ] = a [ s - 1 ][ t * m + i ] * m * 2 + a [ s - 1 ][ t * m + j ]; } m *= 2 ; } } } }","title":"\u5faa\u73af\u8d5b\u65e5\u7a0b\u8868"},{"location":"2/","text":"\u52a8\u6001\u89c4\u5212 \u00b6 \u77e9\u9635\u8fde\u4e58\u95ee\u9898 \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 \u6700\u5927\u5b50\u6bb5\u548c \u51f8\u591a\u8fb9\u5f62\u6700\u4f18\u4e09\u89d2\u5256\u5206 \u591a\u8fb9\u5f62\u6e38\u620f \u56fe\u50cf\u538b\u7f29 \u7535\u8def\u5e03\u7ebf \u6d41\u6c34\u4f5c\u4e1a\u8c03\u5ea6 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u4f18\u4e8c\u53c9\u641c\u7d22\u6811","title":"\u52a8\u6001\u89c4\u5212"},{"location":"2/#_1","text":"\u77e9\u9635\u8fde\u4e58\u95ee\u9898 \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217 \u6700\u5927\u5b50\u6bb5\u548c \u51f8\u591a\u8fb9\u5f62\u6700\u4f18\u4e09\u89d2\u5256\u5206 \u591a\u8fb9\u5f62\u6e38\u620f \u56fe\u50cf\u538b\u7f29 \u7535\u8def\u5e03\u7ebf \u6d41\u6c34\u4f5c\u4e1a\u8c03\u5ea6 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u4f18\u4e8c\u53c9\u641c\u7d22\u6811","title":"\u52a8\u6001\u89c4\u5212"},{"location":"2/1/","text":"void MatrixChain ( int * p , int n , int ** m , int ** s ) { for ( int i = 1 ; i <= n ; ++ i ) { m [ i ][ i ] = 0 ; } for ( int r = 2 ; r <= n ; ++ r ) { for ( int i = 1 ; i <= n - r + 1 ; ++ i ) { int j = i + r - 1 ; m [ i ][ j ] = m [ i + 1 ][ j ] + p [ i - 1 ] * p [ i ] * p [ j ]; s [ i ][ j ] = i ; for ( int k = i + 1 ; k < j ; ++ k ) { int t = m [ i ][ k ] + m [ k + 1 ][ j ] + p [ i - 1 ] * p [ k ] * p [ j ]; if ( t < m [ i ][ j ]) { m [ i ][ j ] = t ; s [ i ][ j ] = k ; } } } } } void Traceback ( int i , int j , int ** s ) { if ( i == j ) return ; Traceback ( i , s [ i ][ j ], s ); Traceback ( s [ i ][ j ] + 1 , j , s ); cout << \"Multiply A\" << i << \",\" << s [ i ][ j ]; cout << \"and A\" << ( s [ i ][ j ] + 1 ) << \",\" << j << endl ; }","title":"\u77e9\u9635\u8fde\u4e58\u95ee\u9898"},{"location":"2/10/","text":"void OptimalBinarySearchTree ( int a , int b , int n , int ** m , int ** s , int ** w ) { for ( int i = 1 ; i <= n ; i ++ ) { w [ i + 1 ][ i ] = a [ i ]; m [ i + 1 ][ i ] = 0 ; } for ( int r = 0 ; r < n ; r ++ ) { for ( int i = 1 ; i <= n - r ; i ++ ) { int j = i + r ; w [ i ][ j ] = w [ i ][ j - 1 ] + a [ j ] + b [ j ]; m [ i ][ j ] = m [ i + 1 ][ j ]; s [ i ][ j ] = i ; for ( int k = i + 1 ; k <= j ; k ++ ) { int t = m [ i ][ k - 1 ] + m [ k + 1 ][ j ]; if ( t < m [ i ][ j ]) { m [ i ][ j ] = t ; s [ i ][ j ] = k ; } } m [ i ][ j ] += w [ i ][ j ]; } } }","title":"\u6700\u4f18\u4e8c\u53c9\u641c\u7d22\u6811"},{"location":"2/2/","text":"void LCS ( const std :: string & s , std :: string & t , int ** c , int ** b ) { int m = s . size (); int n = t . size (); for ( int i = 1 ; i <= m ; ++ i ) { c [ i ][ 0 ] = 0 ; } for ( int j = 1 ; j <= n ; ++ j ) { c [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i <= m ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( s [ i - 1 ] == t [ j - 1 ]) { c [ i ][ j ] = c [ i - 1 ][ j - 1 ] + 1 ; b [ i ][ j ] = 1 ; } else if ( c [ i - 1 ][ j ] >= c [ i ][ j - 1 ]) { c [ i ][ j ] = c [ i - 1 ][ j ]; b [ i ][ j ] = 2 ; } else { c [ i ][ j ] = c [ i ][ j - 1 ]; b [ i ][ j ] = 3 ; } } } } void LCS ( int i , int j , const std :: string & s , int ** b ) { if ( i == 0 || j == 0 ) { return ; } if ( b [ i ][ j ] == 1 ) { LCS ( i - 1 , j - 1 , s , b ); std :: cout << s [ i - 1 ]; } else if ( b [ i ][ j ] == 2 ) { LCS ( i - 1 , j , s , b ); } else { LCS ( i , j - 1 , s , b ); } }","title":"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"2/3/","text":"1d int MaxSum ( const std :: vector < int >& a ) { int n = a . size (); int sum = 0 , b = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( b > 0 ) { b += a [ i ]; } else { b = a [ i ]; } sum = std :: max ( sum , b ); } return sum ; } 2d int MaxSum ( const std :: vector < std :: vector < int >>& a ) { int m = a . size (), n = a [ 0 ]. size (); int sum = 0 ; for ( int i = 0 ; i < m ; ++ i ) { std :: vector < int > b ( n ); for ( int j = i ; j < n ; ++ j ) { for ( int k = 0 ; k < n ; ++ k ) { b [ k ] += a [ j ][ k ]; } sum = std :: max ( sum , MaxSum ( t )); } } return sum ; }","title":"\u6700\u5927\u5b50\u6bb5\u548c"},{"location":"2/4/","text":"\u4e0e\u77e9\u9635\u8fde\u4e58\u76f8\u540c\u3002","title":"\u51f8\u591a\u8fb9\u5f62\u6700\u4f18\u4e09\u89d2\u5256\u5206"},{"location":"2/5/","text":"","title":"\u591a\u8fb9\u5f62\u6e38\u620f"},{"location":"2/6/","text":"int length ( int x ) { int len = 0 ; while ( x ) { len ++ ; x /= 2 ; } return len ; } void Compress ( int n , int p [], int s [], int l [], int b []) { int Lmax = 256 , header = 11 ; s [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { b [ i ] = length ( p [ i ]); int bmax = b [ i ]; s [ i ] = s [ i - 1 ] + bmax ; l [ i ] = 1 ; for ( int j = 2 ; j <= i && j <= Lmax ; j ++ ) { if ( bmax < b [ i - j + 1 ]) { bmax = b [ i - j + 1 ]; } if ( s [ i ] > s [ i - j ] + j * bmax ) { s [ i ] = s [ i - j ] + j * bmax ; l [ i ] = j ; } } s [ i ] += header ; } }","title":"\u56fe\u50cf\u538b\u7f29"},{"location":"2/7/","text":"std :: vector < std :: vector < int >> MNS ( std :: vector < int >& C ) { int n = C . size (); std :: vector < std :: vector < int >> s ( n + 1 , std :: vector < int > ( n + 1 , 0 )); for ( int j = 0 ; j < C [ 1 ]; j ++ ) { s [ 1 ][ j ] = 0 ; } for ( int j = C [ 1 ]; j <= n ; j ++ ) { s [ 1 ][ j ] = 1 ; } for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < C [ i ]; j ++ ) { s [ i ][ j ] = s [ i - 1 ][ j ]; } for ( int j = C [ i ]; j <= n ; j ++ ) { s [ i ][ j ] = std :: max ( s [ i - 1 ][ j ], s [ i - 1 ][ C [ i ] - 1 ] + 1 ); } } s [ n ][ n ] = std :: max ( s [ n - 1 ][ n ], s [ n - 1 ][ C [ n ] - 1 ] + 1 ); } std :: vector < int > Traceback ( std :: vector < int >& C , std :: vector < std :: vector < int >>& s ) { int n = C . size (); std :: vector < int > Net ; for ( int i = n ; i > 1 ; i -- ) { if ( s [ i ][ j ] != s [ i - 1 ][ j ]) { Net . push_back ( i ); j = C [ i ] - 1 ; } if ( j >= C [ 1 ]) { Net . push_back ( 1 ); } } }","title":"\u7535\u8def\u5e03\u7ebf"},{"location":"2/8/","text":"int FlowShop ( int n , int a , int b , int c ) { class Jobtype { public : int key , index ; bool job ; int operator <= ( Jobtype a ) const { return key <= a . key ; } }; Jobtype * d = new Jobtype [ n ]; for ( int i = 0 ; i < n ; i ++ ) { d [ i ]. key = a [ i ] > b [ i ] ? b [ i ] : a [ i ]; d [ i ]. job = a [ i ] <= b [ i ]; d [ i ]. index = i ; } std :: sort ( d , d + n ); int j = 0 , k = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ]. job ) { c [ j ++ ] = d [ i ]. index ; } else { c [ k -- ] = d [ i ]. index ; } } j = a [ c [ 0 ]]; k = j + b [ c [ 0 ]]; for ( int i = 1 ; i < n ; i ++ ) { j += a [ c [ i ]]; k = j > k ? j + b [ c [ i ]] : k + b [ c [ i ]]; } delete [] d ; return k ; }","title":"\u6d41\u6c34\u4f5c\u4e1a\u8c03\u5ea6"},{"location":"2/9/","text":"template < typename T > T knapSack ( const std :: vector < int >& v , const std :: vector < T >& w , int V ) { int n = ( int ) v . size (); std :: vector < T > dp ( V + 1 ); for ( int i = 0 ; i < n ; i ++ ) { for ( int j = V ; j >= v [ i ]; j -- ) { dp [ j ] = std :: max ( dp [ j ], dp [ j - v [ i ]] + w [ i ]); } } return dp . back (); }","title":"0-1 \u80cc\u5305\u95ee\u9898"},{"location":"3/","text":"\u8d2a\u5fc3 \u00b6 \u6d3b\u52a8\u5b89\u6392\u95ee\u9898 \u6700\u4f18\u88c5\u8f7d \u54c8\u592b\u66fc\u7f16\u7801 \u5355\u6e90\u6700\u77ed\u8def\u5f84 \u6700\u5c0f\u751f\u6210\u6811 \u591a\u673a\u8c03\u5ea6\u95ee\u9898","title":"\u8d2a\u5fc3"},{"location":"3/#_1","text":"\u6d3b\u52a8\u5b89\u6392\u95ee\u9898 \u6700\u4f18\u88c5\u8f7d \u54c8\u592b\u66fc\u7f16\u7801 \u5355\u6e90\u6700\u77ed\u8def\u5f84 \u6700\u5c0f\u751f\u6210\u6811 \u591a\u673a\u8c03\u5ea6\u95ee\u9898","title":"\u8d2a\u5fc3"},{"location":"3/1/","text":"template < typename T > void GreedySelector ( int n , T s [], T f [], bool A []) { // sort by finish time A [ 1 ] = true ; int j = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( s [ i ] >= f [ j ]) { A [ i ] = true ; j = i ; } else { A [ i ] = false ; } } }","title":"\u6d3b\u52a8\u5b89\u6392\u95ee\u9898"},{"location":"3/2/","text":"std :: vector < int > Loading ( const std :: vector < int >& w , int V ) { int n = w . size (); std :: vector < int > order ( n ); std :: iota ( order . begin (), order . end (), 0 ); std :: sort ( order . begin (), order . end (), [ & w ]( int i , int j ) { return w [ i ] < w [ j ]; }); std :: vector < int > x ( n ); for ( int i = 0 ; i < n && w [ order [ i ]] <= c ; i ++ ) { x [ order [ i ]] = 1 ; c -= w [ order [ i ]]; } return x ; }","title":"\u6700\u4f18\u88c5\u8f7d"},{"location":"3/3/","text":"class HuffmanTreeNode { public : char data ; // stores character int freq ; // stores of frequency of the character HuffmanTreeNode * left ; // left child of the current node HuffmanTreeNode * right ; // right child of the current node HuffmanTreeNode ( char character , int frequency ) : data ( character ), freq ( frequency ), left ( nullptr ), right ( nullptr ) {} }; // custom comparator class class Compare { public : bool operator ()( HuffmanTreeNode * lhs , HuffmanTreeNode * rhs ) { // defining priority on the basis of frequency return lhs -> freq > rhs -> freq ; } }; // generate Huffman Encoding Tree HuffmanTreeNode * generateTree ( std :: vector < char >& data , std :: vector < int >& freq ) { int size = ( int ) data . size (); std :: priority_queue < HuffmanTreeNode * , std :: vector < HuffmanTreeNode *> , Compare > pq ; for ( int i = 0 ; i < size ; i ++ ) { HuffmanTreeNode * newNode = new HuffmanTreeNode ( data [ i ], freq [ i ]); pq . push ( newNode ); } while ( pq . size () != 1 ) { HuffmanTreeNode * left = pq . top (); pq . pop (); HuffmanTreeNode * right = pq . top (); pq . pop (); HuffmanTreeNode * node = new HuffmanTreeNode ( '$' , left -> freq + right -> freq ); node -> left = left ; node -> right = right ; pq . push ( node ); } return pq . top (); } // print the huffman code for each character void printCodes ( HuffmanTreeNode * root , std :: string & code , std :: vector < std :: pair < char , std :: string >>& codes ) { if ( root -> left ) { code += '0' ; printCodes ( root -> left , code , codes ); code . pop_back (); } if ( root -> right ) { code += '1' ; printCodes ( root -> right , code , codes ); code . pop_back (); } // if this is a leaf node, then we print root -> data if ( ! root -> left && ! root -> right ) { codes . emplace_back ( root -> data , code ); } } std :: vector < std :: pair < char , std :: string >> HuffmanCodes ( HuffmanTreeNode * root ) { std :: vector < std :: pair < char , std :: string >> codes ; std :: string code ( \"\" ); printCodes ( root , code , codes ); return codes ; } int getWPL ( HuffmanTreeNode * root , int len ) { if ( root == nullptr ) { return 0 ; } if ( root -> left == nullptr && root -> right == nullptr ) { return root -> freq * len ; } int lwpl = getWPL ( root -> left , len + 1 ); int rwpl = getWPL ( root -> right , len + 1 ); return lwpl + rwpl ; }","title":"\u54c8\u592b\u66fc\u7f16\u7801"},{"location":"3/4/","text":"Graph template < typename T > class graph { public : struct edge { int from ; int to ; T cost ; }; const int n ; std :: vector < edge > edges ; std :: vector < std :: vector < int >> g ; graph ( int _n ) : n ( _n ), g ( _n ) {} virtual int add ( int from , int to , T cost ) = 0 ; }; template < typename T > class digraph : public graph < T > { public : using graph < T >:: edges ; using graph < T >:: g ; using graph < T >:: n ; digraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); int id = ( int ) edges . size (); g [ from ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } digraph < T > reverse () const { digraph < T > rev ( n ); for ( auto & e : edges ) { rev . add ( e . to , e . from , e . cost ); } return rev ; } }; template < typename T > class undigraph : public graph < T > { public : using graph < T >:: edges ; using graph < T >:: g ; using graph < T >:: n ; undigraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); int id = ( int ) edges . size (); g [ from ]. push_back ( id ); g [ to ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } }; dijkstra template < typename T > std :: vector < T > dijkstra ( const graph < T >& g , int st ) { assert ( 0 <= st && st < g . n ); std :: vector < T > dist ( g . n , std :: numeric_limits < T >:: max ()); std :: priority_queue < std :: pair < T , int > , std :: vector < std :: pair < T , int >> , std :: greater < std :: pair < T , int >> > q ; dist [ st ] = 0 ; q . emplace ( dist [ st ], st ); while ( ! q . empty ()) { T expected = q . top (). first ; int u = q . top (). second ; q . pop (); if ( dist [ u ] != expected ) { continue ; } for ( int id : g . g [ u ]) { auto & e = g . edges [ id ]; int to = e . from ^ e . to ^ u ; if ( dist [ to ] > dist [ u ] + e . cost ) { dist [ to ] = dist [ u ] + e . cost ; q . emplace ( dist [ to ], to ); } } } return dist ; // returns numeric_limits<T>::max() if there's no path }","title":"\u5355\u6e90\u6700\u77ed\u8def\u5f84"},{"location":"3/5/","text":"Graph template < typename T > class graph { public : struct edge { int from ; int to ; T cost ; }; const int n ; std :: vector < edge > edges ; std :: vector < std :: vector < int >> g ; graph ( int _n ) : n ( _n ), g ( _n ) {} virtual int add ( int from , int to , T cost ) = 0 ; }; template < typename T > class digraph : public graph < T > { public : using graph < T >:: edges ; using graph < T >:: g ; using graph < T >:: n ; digraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); int id = ( int ) edges . size (); g [ from ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } digraph < T > reverse () const { digraph < T > rev ( n ); for ( auto & e : edges ) { rev . add ( e . to , e . from , e . cost ); } return rev ; } }; template < typename T > class undigraph : public graph < T > { public : using graph < T >:: edges ; using graph < T >:: g ; using graph < T >:: n ; undigraph ( int _n ) : graph < T > ( _n ) {} int add ( int from , int to , T cost = 1 ) { assert ( 0 <= from && from < n && 0 <= to && to < n ); int id = ( int ) edges . size (); g [ from ]. push_back ( id ); g [ to ]. push_back ( id ); edges . push_back ({ from , to , cost }); return id ; } }; kruskal struct DSU { std :: vector < int > f , siz ; int components = 0 ; DSU ( int n ) : f ( n ), siz ( n , 1 ), components ( n ) { std :: iota ( f . begin (), f . end (), 0 ); } inline int find ( int x ) { while ( x != f [ x ]) { x = f [ x ] = f [ f [ x ]]; } return x ; } bool same ( int x , int y ) { return find ( x ) == find ( y ); } bool merge ( int x , int y ) { x = find ( x ); y = find ( y ); if ( x == y ) { return false ; } siz [ x ] += siz [ y ]; f [ y ] = x ; components -- ; return true ; } int size ( int x ) { return siz [ find ( x )]; } int total_components () { return components ; } }; template < typename T > std :: vector < int > kruskal ( const undigraph < T > & g , T & ans ) { std :: vector < int > order ( g . edges . size ()); iota ( order . begin (), order . end (), 0 ); sort ( order . begin (), order . end (), [ & g ]( int a , int b ) { return g . edges [ a ]. cost < g . edges [ b ]. cost ; }); DSU d ( g . n ); std :: vector < int > ans_list ; ans = 0 ; for ( int id : order ) { auto & e = g . edges [ id ]; if ( ! d . same ( e . from , e . to )) { d . merge ( e . from , e . to ); ans_list . push_back ( id ); ans += e . cost ; } } return ans_list ; // returns edge ids of minimum \"spanning\" forest } prim template < typename T > bool prim ( const undigraph < T > & g , T & ans ) { std :: vector < bool > vis ( g . n ); std :: priority_queue < std :: pair < T , int > , std :: vector < std :: pair < T , int >> , std :: greater < std :: pair < T , int >> > q ; q . push ({ 0 , 0 }); int cnt = 0 ; ans = 0 ; while ( ! q . empty () && cnt < g . n ) { T expected = q . top (). first ; int u = q . top (). second ; q . pop (); if ( vis [ u ]) continue ; vis [ u ] = true ; ans += expected ; cnt ++ ; for ( int id : g . g [ u ]) { auto & e = g . edges [ id ]; int to = e . from ^ e . to ^ u ; if ( ! vis [ to ]) { q . push ({ e . cost , to }); } } } return cnt == g . n ; // returns false if there's not connected }","title":"\u6700\u5c0f\u751f\u6210\u6811"},{"location":"3/6/","text":"class JobNode { friend void Greedy ( JobNode * , int , int ); friend void main ( void ); public : operator int () const { return time ; } private : int ID , time ; }; class MachineNode { friend void Greedy ( JobNode * , int , int ); public : operator int () const { return avail ; } private : int ID , avail ; }; template < class Type > void Greedy ( Type a [], int n , int m ) { if ( n <= m ) { std :: cout << \"\u4e3a\u6bcf\u4e00\u4e2a\u4f5c\u4e1a\u5206\u914d\u4e00\u4e2a\u673a\u5668\" << std :: endl ; return ; } std :: sort ( a , a + n ); MinHeap < MachineNode > H ( m ); MachineNode x ; for ( int i = 0 ; i < m ; i ++ ) { x . avail = 0 ; x . ID = i + 1 ; H . Insert ( x ); } for ( int i = 0 ; i < n ; i ++ ) { H . DeleteMin ( x ); cout << \"\u5c06\u673a\u5668\" << x . ID << \"\u4ece\" << x . avail << \"\u5230\" << x . avail + a [ i ]. time << \"\u7684\u65f6\u95f4\u6bb5\u5206\u914d\u7ed9\u4f5c\u4e1a\" << a [ i ]. ID << endl ; x . avail += a [ i ]. time ; H . Insert ( x ); } }","title":"\u591a\u673a\u8c03\u5ea6\u95ee\u9898"},{"location":"4/","text":"\u56de\u6eaf\u6cd5 \u00b6 \u88c5\u8f7d\u95ee\u9898 \u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6 \u7b26\u53f7\u4e09\u89d2\u5f62\u95ee\u9898 n \u7687\u540e\u95ee\u9898 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u5927\u56e2\u95ee\u9898 \u56fe\u7684 m \u7740\u8272\u95ee\u9898 \u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898 \u5706\u6392\u5217\u95ee\u9898 \u7535\u8def\u677f\u6392\u5217\u95ee\u9898 \u8fde\u7eed\u90ae\u8d44\u95ee\u9898","title":"\u56de\u6eaf\u6cd5"},{"location":"4/#_1","text":"\u88c5\u8f7d\u95ee\u9898 \u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6 \u7b26\u53f7\u4e09\u89d2\u5f62\u95ee\u9898 n \u7687\u540e\u95ee\u9898 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u5927\u56e2\u95ee\u9898 \u56fe\u7684 m \u7740\u8272\u95ee\u9898 \u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898 \u5706\u6392\u5217\u95ee\u9898 \u7535\u8def\u677f\u6392\u5217\u95ee\u9898 \u8fde\u7eed\u90ae\u8d44\u95ee\u9898","title":"\u56de\u6eaf\u6cd5"},{"location":"4/1/","text":"template < class T > T MaxLoading ( std :: vector < T >& w , T c , int n , std :: vector < int >& bestx ) { int i = 1 ; std :: vector < int > x ( n + 1 ); T bestw = 0 , cw = 0 , r = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { r += w [ j ]; } while ( true ) { while ( i <= n && cw + w [ i ] <= c ) { r -= w [ i ]; cw += w [ i ]; x [ i ] = 1 ; i ++ ; } if ( i > n ) { for ( int j = 1 ; j <= n ; j ++ ) { bestx [ j ] = x [ j ]; bestw = cw ; } } else { r -= w [ i ]; x [ i ] = 0 ; i ++ ; } while ( cw + r <= bestw ) { i -- ; while ( i > 0 && ! x [ i ]) { r += w [ i ]; i -- ; } if ( i == 0 ) { return bestw ; } x [ i ] = 0 ; cw -= w [ i ]; i ++ ; } } }","title":"\u88c5\u8f7d\u95ee\u9898"},{"location":"4/10/","text":"class Board { friend Arrangement ( int ** , int , int , int []); private : void Backtrack ( int i , int cd ); int n , m , * x , * bestx , bestd , * total , * now , ** B ; }; void Board::Backtrack ( int i , int cd ) { if ( i == n ) { for ( int j = 1 ; j <= n ; j ++ ) { bestx [ j ] = x [ j ]; } bestd = cd ; } else { for ( int j = i ; j <= n ; j ++ ) { int ld = 0 ; for ( int k = 1 ; k <= m ; k ++ ) { now [ k ] += B [ x [ j ]][ k ]; if ( now [ k ] > 0 && total [ k ] != now [ k ]) { ld ++ ; } } if ( cd > ld ) { ld = cd ; } if ( ld < bestd ) { Swap ( x [ i ], x [ j ]); Backtrack ( i + 1 , ld ); Swap ( x [ i ], x [ j ]); } for ( int k = 1 ; k <= m ; k ++ ) { now [ k ] -= B [ x [ j ]][ k ]; } } } } int Arrangement ( int ** B , int n , int m , int bestx []) { Board X ; X . x = new int [ n + 1 ]; X . total = new int [ m + 1 ]; X . now = new int [ m + 1 ]; X . B = B ; X . n = n ; X . m = m ; X . bestx = bestx ; X . bestd = m + 1 ; for ( int i = 1 ; i <= m ; i ++ ) { X . total [ i ] = 0 ; X . now [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { X . x [ i ] = i ; for ( int j = 1 ; j <= m ; j ++ ) { X . total [ j ] += B [ i ][ j ]; } } X . Backtrack ( 1 , 0 ); delete [] X . x ; delete [] X . total ; delete [] X . now ; return X . bestd ; }","title":"\u7535\u8def\u677f\u6392\u5217\u95ee\u9898"},{"location":"4/11/","text":"","title":"\u8fde\u7eed\u90ae\u8d44\u95ee\u9898"},{"location":"4/2/","text":"class Flowshop { friend Flow ( int ** , int , int []); private : void Backtrack ( int i ); int ** M , * x , * bestx , * f2 , f1 , f , bestf , n ; }; void Flowshop::Backtrack ( int i ) { if ( i > n ) { for ( int j = 1 ; j <= n ; j ++ ) { bestx [ j ] = x [ j ]; } bestf = f ; } else { for ( int j = i ; j <= n ; j ++ ) { f1 += M [ x [ j ]][ 1 ]; f2 [ i ] = (( f2 [ i - 1 ] > f1 ) ? f2 [ i - 1 ] : f1 ) + M [ x [ j ]][ 2 ]; f += f2 [ i ]; if ( f < bestf ) { Swap ( x [ i ], x [ j ]); Backtrack ( i + 1 ); Swap ( x [ i ], x [ j ]); } f1 -= M [ x [ j ]][ 1 ]; f -= f2 [ i ]; } } } int Flow ( int ** M , int n , int bestx []) { int ub = INT_MAX ; Flowshop X ; X . x = new int [ n + 1 ]; X . f2 = new int [ n + 1 ]; X . M = M ; X . n = n ; X . bestx = bestx ; X . bestf = ub ; X . f1 = 0 ; X . f = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { X . f2 [ i ] = 0 ; X . x [ i ] = i ; } X . Backtrack ( 1 ); delete [] X . x ; delete [] X . f2 ; return X . bestf ; }","title":"\u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6"},{"location":"4/3/","text":"class Triangle { friend int Compute ( int ); private : void Backtrack ( int t ); int n , half , count , ** p ; long sum ; }; void Triangle::Backtrack ( int t ) { if (( count > half ) || ( t * ( t - 1 ) / 2 - count > half )) { return ; } if ( t > n ) { sum ++ ; } else { for ( int i = 0 ; i < 2 ; i ++ ) { p [ 1 ][ t ] = i ; count += i ; for ( int j = 2 ; j <= t ; j ++ ) { p [ j ][ t - j + 1 ] = p [ j - 1 ][ t - j + 1 ] ^ p [ j - 1 ][ t - j + 2 ]; count += p [ j ][ t - j + 1 ]; } Backtrack ( t + 1 ); for ( int j = 2 ; j <= t ; j ++ ) { count -= p [ j ][ t - j + 1 ]; } count -= i ; } } } int Compute ( int n ) { Triangle X ; X . n = n ; X . count = 0 ; X . sum = 0 ; X . half = n * ( n + 1 ) / 4 ; if ( X . half % 2 == 1 ) { return 0 ; } X . half /= 2 ; int ** p = new int * [ n + 1 ]; for ( int i = 0 ; i <= n ; i ++ ) { p [ i ] = new int [ n + 1 ]; } for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) p [ i ][ j ] = 0 ; X . p = p ; X . Backtrack ( 1 ); return X . sum ; }","title":"\u7b26\u53f7\u4e09\u89d2\u5f62\u95ee\u9898"},{"location":"4/4/","text":"class Queen { friend int nQueen ( int ); private : bool Place ( int k ); void Backtrack ( int t ); int n , * x ; long sum ; } bool Queen :: Place ( int k ) { for ( int j = 1 ; j < k ; j ++ ) { if (( abs ( k - j ) == abs ( x [ j ] - x [ k ])) || ( x [ j ] == x [ k ])) { return false ; } } return true ; } void Queen :: Backtrack ( int t ) { if ( t > n ) { sum ++ ; } else { for ( int i = 1 ; i <= n ; i ++ ) { x [ t ] = i ; if ( Place ( t )) { Backtrack ( t + 1 ); } } } } int nQueen ( int n ) { Queen X ; X . n = n ; X . sum = 0 ; int * p = new int [ n + 1 ]; for ( int i = 0 ; i <= n ; i ++ ) { p [ i ] = 0 ; } X . x = p ; X . Backtrack ( 1 ); delete [] p ; return X . sum ; }","title":"n \u7687\u540e\u95ee\u9898"},{"location":"4/5/","text":"template < class Typew , class Typep > class Knap { friend Typep Knapsack ( Typep * , Typew * , Typew , int ); private : Typep Bound ( int i ); void Backtrack ( int i ); Typew c ; int n ; Typew * w ; Typep * p ; Typew cw ; Typep cp ; Typep bestp ; }; template < class Typew , class Typep > void Knap < Typew , Typep >:: Backtrack ( int i ) { if ( i > n ) { bestp = cp ; return ; } if ( cw + w [ i ] <= c ) { cw += w [ i ]; cp += p [ i ]; Backtrack ( i + 1 ); cw -= w [ i ]; cp -= p [ i ]; } if ( Bound ( i + 1 ) > bestp ) { Backtrack ( i + 1 ); } } template < class Typew , class Typep > Typep Knap < Typew , Typep >:: Bound ( int i ) { Typew cleft = c - cw ; Typep b = cp ; while ( i <= n && w [ i ] <= cleft ) { cleft -= w [ i ]; b += p [ i ]; i ++ ; } if ( i <= n ) { b += p [ i ] / w [ i ] * cleft ; } return b ; } class Object { friend int Knapsack ( int * , int * , int , int ); public : int operator <= ( Object a ) const { return d >= a . d ; } private : int ID ; float d ; }; template < class Typew , class Typep > Typep Knapsack ( Typep p [], Typew w [], Typew c , int n ) { Typew W = 0 ; Typep P = 0 ; Object * Q = new Object [ n ]; for ( int i = 1 ; i <= n ; i ++ ) { Q [ i - 1 ]. ID = i ; Q [ i - 1 ]. d = ( float ) p [ i ] / w [ i ]; P += p [ i ]; W += w [ i ]; } if ( W <= c ) return P ; Sort ( Q , n ); Knap < Typew , Typep > K ; K . p = new Typep [ n + 1 ]; K . w = new Typew [ n + 1 ]; for ( int i = 1 ; i <= n ; i ++ ) { K . p [ i ] = p [ Q [ i - 1 ]. ID ]; K . w [ i ] = w [ Q [ i - 1 ]. ID ]; } K . cp = 0 ; K . cw = 0 ; K . c = c ; K . n = n ; K . bestp = 0 ; K . Backtrack ( 1 ); delete [] Q ; delete [] K . p ; delete [] K . w ; return K . bestp ; }","title":"0-1 \u80cc\u5305\u95ee\u9898"},{"location":"4/6/","text":"class Clique { friend int MaxClique ( int ** , int [], int ); private : void Backtrack ( int i ); int ** a , n , * x , * bestx , cn , bestn ; }; void Clique::Backtrack ( int i ) { if ( i > n ) { for ( int j = 1 ; j <= n ; j ++ ) { bestx [ j ] = x [ j ]; } bestn = cn ; return ; } int ok = 1 ; for ( int j = 1 ; j < i ; j ++ ) { if ( x [ j ] && ! a [ i ][ j ]) { ok = 0 ; break ; } } if ( ok ) { x [ i ] = 1 ; cn ++ ; Backtrack ( i + 1 ); x [ i ] = 0 ; cn -- ; } if ( cn + n - i > bestn ) { x [ i ] = 0 ; Backtrack ( i + 1 ); } } int MaxClique ( int ** a , int v [], int n ) { Clique Y ; Y . x = new int [ n + 1 ]; Y . a = a ; Y . n = n ; Y . cn = 0 ; Y . bestn = 0 ; Y . bestx = v ; Y . Backtrack ( 1 ); delete [] Y . x ; return Y . bestn ; }","title":"\u6700\u5927\u56e2\u95ee\u9898"},{"location":"4/7/","text":"class Color { friend int mColoring ( int , int , int ** ); private : bool Ok ( int k ); void Backtrack ( int t ); int n , m , ** a , * x ; long sum ; }; bool Color::Ok ( int k ) { for ( int j = 1 ; j < k ; j ++ ) { if ( a [ k ][ j ] && x [ j ] == x [ k ]) { return false ; } } return true ; } void Color::Backtrack ( int t ) { if ( t > n ) { sum ++ ; for ( int i = 1 ; i <= n ; i ++ ) { cout << x [ i ] << \" \" ; } cout << endl ; } else { for ( int i = 1 ; i <= m ; i ++ ) { x [ t ] = i ; if ( Ok ( t )) { Backtrack ( t + 1 ); } x [ t ] = 0 ; } } } int mColoring ( int n , int m , int ** a ) { Color X ; X . n = n ; X . m = m ; X . a = a ; X . sum = 0 ; int * p = new int [ n + 1 ]; for ( int i = 0 ; i <= n ; i ++ ) p [ i ] = 0 ; X . x = p ; X . Backtrack ( 1 ); delete [] p ; return X . sum ; }","title":"\u56fe\u7684 m \u7740\u8272\u95ee\u9898"},{"location":"4/8/","text":"template < class Type > class Traveling { friend Type TSP ( int ** , int [], int , Type ); private : void Backtrack ( int i ); int n , * x , * bestx ; Type ** a , cc , bestc , NoEdge ; }; template < class Type > void Traveling < Type >:: Backtrack ( int i ) { if ( i == n ) { if ( a [ x [ n - 1 ]][ x [ n ]] != NoEdge && a [ x [ n ]][ 1 ] != NoEdge && ( cc + a [ x [ n - 1 ]][ x [ n ]] + a [ x [ n ]][ 1 ] < bestc || bestc == NoEdge )) { for ( int j = 1 ; j <= n ; j ++ ) { bestx [ j ] = x [ j ]; } bestc = cc + a [ x [ n - 1 ]][ x [ n ]] + a [ x [ n ]][ 1 ]; } } else { for ( int j = i ; j <= n ; j ++ ) { if ( a [ x [ i - 1 ]][ x [ j ]] != NoEdge && ( cc + a [ x [ i - 1 ]][ x [ j ]] < bestc || bestc == NoEdge )) { Swap ( x [ i ], x [ j ]); cc += a [ x [ i - 1 ]][ x [ i ]]; Backtrack ( i + 1 ); cc -= a [ x [ i - 1 ]][ x [ i ]]; Swap ( x [ i ], x [ j ]); } } } } template < class Type > Type TSP ( int ** a , int v [], int n , Type noEdge ) { Traveling < Type > Y ; Y . x = new int [ n + 1 ]; for ( int i = 1 ; i <= n ; i ++ ) { Y . x [ i ] = i ; } Y . a = a ; Y . n = n ; Y . bestc = noEdge ; Y . bestx = v ; Y . cc = 0 ; Y . NoEdge = noEdge ; Y . Backtrack ( 2 ); delete [] Y . x ; return Y . bestc ; }","title":"\u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898"},{"location":"4/9/","text":"class Circle { friend float CirclePerm ( int , float * ); private : float Center ( int t ); void Compute ( void ); void Backtrack ( int t ); float min , * x , * r ; int n ; }; float Circle::Center ( int t ) { float temp = 0 ; for ( int j = 1 ; j < t ; j ++ ) { float valuex = x [ j ] + 2 * sqrt ( r [ j ] * r [ t ]); if ( valuex > temp ) { temp = valuex ; } } return temp ; } void Circle::Compute ( void ) { float low = 0 , high = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x [ i ] - r [ i ] < low ) { low = x [ i ] - r [ i ]; } if ( x [ i ] + r [ i ] > high ) { high = x [ i ] + r [ i ]; } } if ( high - low < min ) { min = high - low ; } } void Circle::Backtrack ( int t ) { if ( t > n ) Compute (); else { for ( int j = t ; j <= n ; j ++ ) { Swap ( r [ t ], r [ j ]); float centerx = Center ( t ); if ( centerx + r [ t ] + r [ 1 ] < min ) { x [ t ] = centerx ; Backtrack ( t + 1 ); } Swap ( r [ t ], r [ j ]); } } } float CirclePerm ( int n , float * a ) { Circle X ; X . n = n ; X . r = a ; X . min = 100000 ; X . x = new float [ n + 1 ]; X . Backtrack ( 1 ); delete [] X . x ; return X . min ; }","title":"\u5706\u6392\u5217\u95ee\u9898"},{"location":"5/","text":"\u5206\u652f\u9650\u754c\u6cd5 \u00b6 \u5355\u6e90\u6700\u77ed\u8def\u5f84\u95ee\u9898 \u88c5\u8f7d\u95ee\u9898 \u5e03\u7ebf\u95ee\u9898 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u5927\u56e2\u95ee\u9898 \u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898 \u7535\u8def\u677f\u6392\u5217\u95ee\u9898 \u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6","title":"\u5206\u652f\u9650\u754c\u6cd5"},{"location":"5/#_1","text":"\u5355\u6e90\u6700\u77ed\u8def\u5f84\u95ee\u9898 \u88c5\u8f7d\u95ee\u9898 \u5e03\u7ebf\u95ee\u9898 0-1 \u80cc\u5305\u95ee\u9898 \u6700\u5927\u56e2\u95ee\u9898 \u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898 \u7535\u8def\u677f\u6392\u5217\u95ee\u9898 \u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6","title":"\u5206\u652f\u9650\u754c\u6cd5"},{"location":"5/1/","text":"template < class Type > class Graph { friend void main ( void ); public : void ShortestPaths ( int ); private : int n , * prev ; Type ** c , * dist ; }; template < class Type > class MinHeapNode { friend Graph < Type > ; public : operator int () const { return length ; } private : int i ; Type length ; }; template < class Type > void Graph < Type >:: ShortestPaths ( int v ) { MinHeap < MinHeapNode < Type >> H ( 1000 ); MinHeapNode < Type > E ; E . i = v ; E . length = 0 ; dist [ v ] = 0 ; while ( true ) { for ( int j = 1 ; j <= n ; j ++ ) { if (( c [ E . i ][ j ] < maxWeight ) && ( E . length + c [ E . i ][ j ] < dist [ j ])) { dist [ j ] = E . length + c [ E . i ][ j ]; prev [ j ] = E . i ; MinHeapNode < Type > N ; N . i = j ; N . length = dist [ j ]; H . Insert ( N ); } try { H . DeleteMin ( E ); } catch ( OutOfBounds ) { break ; } } } }","title":"\u5355\u6e90\u6700\u77ed\u8def\u5f84\u95ee\u9898"},{"location":"5/2/","text":"template < class Type > HeapNode ; class bbnode { friend void AddLiveNode ( MaxHeap < HeapNode < int >>& , bbnode * , int , bool , int ); friend int MaxLoading ( int * , int , int , int * ); friend class AdjacencyGraph ; private : bbnode * parent ; bool LChild ; }; template < class Type > class HeapNode { friend void AddLiveNode ( MaxHeap < HeapNode < int >>& , bbnode * , int , bool , int ); friend Type MaxLoading ( Type * , Type , int , int * ); public : operator Type () const { return uweight ; }; private : bbnode * ptr ; Type uweight ; int level ; }; template < class Type > void AddLiveNode ( MaxHeap < HeapNode < Type >> & H , bbnode * E , int wt , bool ch , int lev ) { bbnode * b = new bbnode ; b -> parent = E ; b -> LChild = ch ; HeapNode < Type > N ; N . uweight = wt ; N . level = lev ; N . ptr = b ; H . Insert ( N ); } template < class Type > Type MaxLoading ( Type w [], Type c , int n , int bestx []) { MaxHeap < HeapNode < Type >> H ( 1000 ); Type * r = new Type [ n + 1 ]; r [ n ] = 0 ; for ( int j = n - 1 ; j > 0 ; j -- ) r [ j ] = r [ j + 1 ] + w [ j + 1 ]; int i = 1 ; bbnode * E = 0 ; Type Ew = 0 ; while ( i != n + 1 ) { if ( Ew + w [ i ] <= c ) { AddLiveNode ( H , E , Ew + w [ i ] + r [ i ], true , i + 1 ); } AddLiveNode ( H , E , Ew + r [ i ], false , i + 1 ); HeapNode < Type > N ; H . DeleteMax ( N ); i = N . level ; E = N . ptr ; Ew = N . uweight - r [ i - 1 ]; } for ( int j = n ; j > 0 ; j -- ) { bestx [ j ] = E -> LChild ; E = E -> parent ; } return Ew ; }","title":"\u88c5\u8f7d\u95ee\u9898"},{"location":"5/3/","text":"bool FindPath ( Position start , Position finish , int & PathLen , Position * & path ) { if (( start . row == finish . row ) && ( start . col == finish . col )) { PathLen = 0 ; return true ; } for ( int i = 0 ; i <= m + 1 ; i ++ ) { grid [ 0 ][ i ] = grid [ n + 1 ][ i ] = 1 ; } for ( int i = 0 ; i <= n + 1 ; i ++ ) { grid [ i ][ 0 ] = grid [ i ][ m + 1 ] = 1 ; } Position offset [ 4 ]; offset [ 0 ]. row = 0 ; offset [ 0 ]. col = 1 ; offset [ 1 ]. row = 1 ; offset [ 1 ]. col = 0 ; offset [ 2 ]. row = 0 ; offset [ 2 ]. col = -1 ; offset [ 3 ]. row = -1 ; offset [ 3 ]. col = 0 ; int NumOfNbrs = 4 ; Position here , nbr ; here . row = start . row ; here . col = start . col ; grid [ start . row ][ start . col ] = 2 ; LinkedQueue < Position > Q ; do { for ( int i = 0 ; i < NumOfNbrs ; i ++ ) { nbr . row = here . row + offset [ i ]. row ; nbr . col = here . col + offset [ i ]. col ; if ( grid [ nbr . row ][ nbr . col ] == 0 ) { grid [ nbr . row ][ nbr . col ] = grid [ here . row ][ here . col ] + 1 ; if (( nbr . row == finish . row ) && ( nbr . col == finish . col )) { break ; } Q . Add ( nbr ); } } if (( nbr . row == finish . row ) && ( nbr . col == finish . col )) { break ; } if ( Q . IsEmpty ()) { return false ; } Q . Delete ( here ); } while ( true ); PathLen = grid [ finish . row ][ finish . col ] - 2 ; path = new Position [ PathLen ]; here = finish ; for ( int j = PathLen - 1 ; j >= 0 ; j -- ) { path [ j ] = here ; for ( int i = 0 ; i < NumOfNbrs ; i ++ ) { nbr . row = here . row + offset [ i ]. row ; nbr . col = here . col + offset [ i ]. col ; if ( grid [ nbr . row ][ nbr . col ] == j + 2 ) { break ; } } here = nbr ; } return true ; }","title":"\u5e03\u7ebf\u95ee\u9898"},{"location":"5/4/","text":"class Object { friend int Knapsack ( int * , int * , int , int , int * ); public : int operator <= ( Object a ) const { return d >= a . d ; } private : int ID ; float d ; }; template < class Typew , class Typep > class Knap ; class bbnode { friend Knap < int , int > ; friend int Knapsack ( int * , int * , int , int , int * ); private : bbnode * parent ; bool LChild ; }; template < class Typew , class Typep > class HeapNode { friend Knap < Typew , Typep > ; public : operator Typep () const { return uprofit ; } private : Typep uprofit , profit ; Typew weight ; int level ; bbnode * ptr ; }; template","title":"0-1 \u80cc\u5305\u95ee\u9898"},{"location":"5/5/","text":"class bbnode { friend class Clique ; private : bbnode * parent ; bool LChild ; }; class CliqueNode { friend class Clique ; public : operator int () const { return un ; } private : int cn , un , level ; bbnode * ptr ; }; class Clique { friend void main ( void ); public : int BBMaxClique ( int []); private : void AddLiveNode ( MaxHeap < CliqueNode > & H , int cn , int un , int level , bbnode E [], bool ch ); int ** a , n ; void Clique::AddLiveNode ( MaxHeap < CliqueNode > & H , int cn , int un , int level , bbnode E [], bool ch ) { bbnode * b = new bbnode ; b -> parent = E ; b -> LChild = ch ; CliqueNode N ; N . cn = cn ; N . ptr = b ; N . un = un ; N . level = level ; H . Insert ( N ); } int Clique::BBMaxClique ( int bestx []) { MaxHeap < CliqueNode > H ( 1000 ); bbnode * E = 0 ; int i = 0 , cn = 0 , bestn = 0 ; while ( i != n + 1 ) { bool OK = true ; bbnode * B = E ; for ( int j = i - 1 ; j > 0 ; B = B -> parent , j -- ) { if ( B -> LChild && a [ i ][ j ] == 0 ) { OK = false ; break ; } if ( OK ) { if ( cn + 1 > bestn ) bestn = cn + 1 ; AddLiveNode ( H , cn + 1 , cn + n - i + 1 , i + 1 , E , true ); } if ( cn + n - i >= bestn ) { AddLiveNode ( H , cn , cn + n - i , i + 1 , E , false ); } CliqueNode N ; H . DeleteMax ( N ); E = N . ptr ; cn = N . cn ; i = N . level ; } } for ( int j = n ; j > 0 ; j -- ) { bestx [ j ] = E -> LChild ; E = E -> parent ; } return bestn ; }","title":"\u6700\u5927\u56e2\u95ee\u9898"},{"location":"5/6/","text":"template < class Type > class Traveling { friend void main ( void ); public : Type BBTSP ( int v []); private : int n ; Type ** a , cc , bestc , NoEdge ; }; template < class Type > class MinHeapNode { friend Traveling < Type > ; public : operator Type () const { return lcost ; } private : Type lcost , cc , rcost ; int s , * x ; }; template < class Type > Type Traveling < Type >:: BBTSP ( int v []) { MinHeap < MinHeapNode < Type >> H ( 1000 ); Type * MinOut = new Type [ n + 1 ]; Type MinSum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { Type Min = NoEdge ; for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i ][ j ] != NoEdge && ( Min == NoEdge || Min > a [ i ][ j ])) Min = a [ i ][ j ]; } if ( Min == NoEdge ) return NoEdge ; MinOut [ i ] = Min ; MinSum += Min ; } MinHeapNode < Type > E ; E . x = new int [ n ]; for ( int i = 0 ; i < n ; i ++ ) E . x [ i ] = i ; E . s = 0 ; E . cc = 0 ; E . rcost = MinSum ; Type bestc = NoEdge ; while ( E . s < n - 1 ) { if ( E . s == n - 2 ) { if ( a [ E . x [ n -2 ]][ E . x [ n -1 ]] != NoEdge && a [ E . x [ n -1 ]][ 1 ] != NoEdge && ( bestc == NoEdge || bestc > E . cc + a [ E . x [ n -2 ]][ E . x [ n -1 ]] + a [ E . x [ n -1 ]][ 1 ])) { bestc = E . cc + a [ E . x [ n -2 ]][ E . x [ n -1 ]] + a [ E . x [ n -1 ]][ 1 ]; E . cc = bestc ; E . lcost = bestc ; E . s ++ ; H . Insert ( E ); } else { delete [] E . x ; } } else { for ( int i = E . s + 1 ; i < n ; i ++ ) { if ( a [ E . x [ E . s ]][ E . x [ i ]] != NoEdge ) { Type cc = E . cc + a [ E . x [ E . s ]][ E . x [ i ]]; Type rcost = E . rcost - MinOut [ E . x [ E . s ]]; Type b = cc + rcost ; if ( bestc == NoEdge || bestc > b ) { MinHeapNode < Type > N ; N . x = new int [ n ]; for ( int j = 0 ; j < n ; j ++ ) N . x [ j ] = E . x [ j ]; N . x [ E . s + 1 ] = E . x [ i ]; N . x [ i ] = E . x [ E . s + 1 ]; N . s = E . s + 1 ; N . cc = cc ; N . rcost = rcost ; N . lcost = b ; H . Insert ( N ); } } } delete [] E . x ; } try { H . DeleteMin ( E ); } catch ( OutOfBounds ) { break ; } } if ( bestc == NoEdge ) return NoEdge ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = E . x [ i ]; while ( true ) { delete [] E . x ; try { H . DeleteMin ( E ); } catch ( OutOfBounds ) { break ; } } return bestc ; }","title":"\u65c5\u884c\u552e\u8d27\u5458\u95ee\u9898"},{"location":"5/7/","text":"class BoardNode { friend int BBArrangement ( int ** , int , int , int * & ); public : operator int () const { return cd ; } private : int * x , s , cd , * now ; }; int BBArrangement ( int ** B , int n , int m , int * & bestx ) { MinHeap < BoardNode > H ( 1000 ); BoardNode E ; E . x = new int [ n + 1 ]; E . s = 0 ; E . cd = 0 ; E . now = new int [ m + 1 ]; int * total = new int [ m + 1 ]; for ( int i = 1 ; i <= m ; i ++ ) total [ i ] = 0 ; E . now [ i ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { E . x [ i ] = i ; for ( int j = 1 ; j <= m ; j ++ ) { total [ j ] += B [ i ][ j ]; } } int bestd = m + 1 ; bestx = 0 ; do { if ( E . s == n - 1 ) { int ld = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { ld += B [ E . x [ n ]][ j ]; if ( ld < bestd ) { delete [] bestx ; bestx = E . x ; bestd = max ( ld , E . cd ); } else { delete [] E . x ; } delete [] E . now ; } } else { for ( int i = E . s + 1 ; i <= n ; i ++ ) { BoardNode N ; N . now = new int [ m + 1 ]; for ( int j = 1 ; j <= m ; j ++ ) N . now [ j ] = E . now [ j ] + B [ E . x [ i ]][ j ]; int ld = 0 ; for ( int j = 1 ; j <= m ; j ++ ) if ( N . now [ j ] > 0 && total [ j ] != N . now [ j ]) ld ++ ; N . cd = max ( ld , E . cd ); if ( N . cd < bestd ) { N . x = new int [ n + 1 ]; N . s = E . s + 1 ; for ( int j = 1 ; j <= n ; j ++ ) N . x [ j ] = E . x [ j ]; N . x [ N . s ] = E . x [ i ]; N . x [ i ] = E . x [ N . s ]; H . Insert ( N ); } else { delete [] N . now ; } delete [] E . x ; } try { H . DeleteMin ( E ); } catch ( OutOfBounds ) { return bestd ; } } } while ( E . cd < bestd ); do { delete [] E . x ; delete [] E . now ; try { H . DeleteMin ( E ); } catch (...) { break ; } } while ( true ); return bestd ; }","title":"\u7535\u8def\u677f\u6392\u5217\u95ee\u9898"},{"location":"5/8/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6 class Flowshop ; class MinHeapNode { friend Flowshop ; public : operator int () const { return bb ; } private : void Init ( int ), NewNode ( MinHeapNode , int , int , int , int ); int s , f1 , f2 , sf2 , bb , * x ; }; void MinHeapNode::Init ( int n ) { x = new int [ n + 1 ]; for ( int i = 1 ; i <= n ; i ++ ) x [ i ] = 0 ; s = 0 ; f1 = 0 ; f2 = 0 ; sf2 = 0 ; bb = 0 ; } void MinHeapNode::NewNode ( MinHeapNode E , int Ef1 , int Ef2 , int Ebb , int n ) { x = new int [ n ]; for ( int i = 0 ; i < n ; i ++ ) x [ i ] = E . x [ i ]; f1 = Ef1 ; f2 = Ef2 ; sf2 = E . sf2 + f2 ; bb = Ebb ; s = E . s + 1 ; } class Flowshop { friend void main ( void ); public : int BBFlow ( void ); private : int Bound ( MinHeapNode , int & , int & , bool ** ); void Sort ( void ); int n , ** M , ** b , ** a , * bestx , bestc ; bool ** y ; }; void Flowshop::Sort ( void ) { int * c = new int [ n ]; for ( int j = 0 ; j < 2 ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { b [ i ][ j ] = M [ i ][ j ]; c [ i ] = i ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int k = n - 1 ; k > i ; k -- ) { if ( b [ k ][ j ] < b [ k - 1 ][ j ]) { Swap ( b [ k ][ j ], b [ k - 1 ][ j ]); Swap ( c [ k ], c [ k - 1 ]); } for ( int i = 0 ; i < n ; i ++ ) a [ c [ i ]][ j ] = i ; } } } delete [] c ; } int Flowshop::Bound ( MinHeapNode E , int & f1 , int & f2 , bool ** y ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { y [ k ][ j ] = false ; } } for ( int k = 0 ; k <= E . s ; k ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { y [ a [ E . x [ k ]][ j ]][ j ] = true ; } } f1 = E . f1 + M [ E . x [ E . s ]][ 0 ]; f2 = ( f1 > E . f2 ? f1 : E . f2 ) + M [ E . x [ E . s ]][ 1 ]; int sf2 = E . sf2 + f2 ; int s1 = 0 , s2 = 0 , k1 = n - E . s , k2 = n - E . s , f3 = f2 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ! y [ j ][ 0 ]) { k1 -- ; if ( k1 == n - E . s - 1 ) { f3 = ( f2 > f1 + b [ j ][ 0 ]) ? f2 : f1 + b [ j ][ 0 ]; } s1 += f1 + k1 * b [ j ][ 0 ]; } } for ( int j = 0 ; j < n ; j ++ ) { if ( ! y [ j ][ 1 ]) { k2 -- ; s1 += b [ j ][ 1 ]; s2 += f3 + k2 * b [ j ][ 1 ]; } } return sf2 + ( s1 < s2 ? s2 : s1 ); } int Flowshop::BBFlow ( void ) { Sort (); MinHeap < MinHeapNode > H ( 1000 ); MinHeapNode E ; E . Init ( n ); while ( E . s <= n ) { if ( E . s == n ) { if ( E . sf2 < bestc ) { bestc = E . sf2 ; for ( int i = 0 ; i < n ; i ++ ) bestx [ i ] = E . x [ i ]; } delete [] E . x ; } else { for ( int i = E . s ; i < n ; i ++ ) { Swap ( E . x [ E . s ], E . x [ i ]); int f1 , f2 ; int bb = Bound ( E , f1 , f2 , y ); if ( bb < bestc ) { MinHeapNode N ; N . NewNode ( E , f1 , f2 , bb , n ); H . Insert ( N ); } Swap ( E . x [ E . s ], E . x [ i ]); } delete [] E . x ; } try { H . DeleteMin ( E ); } catch ( OutOfBounds ) { break ; } } return bestc ; }","title":"\u6279\u5904\u7406\u4f5c\u4e1a\u8c03\u5ea6"},{"location":"5/8/#_1","text":"class Flowshop ; class MinHeapNode { friend Flowshop ; public : operator int () const { return bb ; } private : void Init ( int ), NewNode ( MinHeapNode , int , int , int , int ); int s , f1 , f2 , sf2 , bb , * x ; }; void MinHeapNode::Init ( int n ) { x = new int [ n + 1 ]; for ( int i = 1 ; i <= n ; i ++ ) x [ i ] = 0 ; s = 0 ; f1 = 0 ; f2 = 0 ; sf2 = 0 ; bb = 0 ; } void MinHeapNode::NewNode ( MinHeapNode E , int Ef1 , int Ef2 , int Ebb , int n ) { x = new int [ n ]; for ( int i = 0 ; i < n ; i ++ ) x [ i ] = E . x [ i ]; f1 = Ef1 ; f2 = Ef2 ; sf2 = E . sf2 + f2 ; bb = Ebb ; s = E . s + 1 ; } class Flowshop { friend void main ( void ); public : int BBFlow ( void ); private : int Bound ( MinHeapNode , int & , int & , bool ** ); void Sort ( void ); int n , ** M , ** b , ** a , * bestx , bestc ; bool ** y ; }; void Flowshop::Sort ( void ) { int * c = new int [ n ]; for ( int j = 0 ; j < 2 ; j ++ ) { for ( int i = 0 ; i < n ; i ++ ) { b [ i ][ j ] = M [ i ][ j ]; c [ i ] = i ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int k = n - 1 ; k > i ; k -- ) { if ( b [ k ][ j ] < b [ k - 1 ][ j ]) { Swap ( b [ k ][ j ], b [ k - 1 ][ j ]); Swap ( c [ k ], c [ k - 1 ]); } for ( int i = 0 ; i < n ; i ++ ) a [ c [ i ]][ j ] = i ; } } } delete [] c ; } int Flowshop::Bound ( MinHeapNode E , int & f1 , int & f2 , bool ** y ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { y [ k ][ j ] = false ; } } for ( int k = 0 ; k <= E . s ; k ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { y [ a [ E . x [ k ]][ j ]][ j ] = true ; } } f1 = E . f1 + M [ E . x [ E . s ]][ 0 ]; f2 = ( f1 > E . f2 ? f1 : E . f2 ) + M [ E . x [ E . s ]][ 1 ]; int sf2 = E . sf2 + f2 ; int s1 = 0 , s2 = 0 , k1 = n - E . s , k2 = n - E . s , f3 = f2 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ! y [ j ][ 0 ]) { k1 -- ; if ( k1 == n - E . s - 1 ) { f3 = ( f2 > f1 + b [ j ][ 0 ]) ? f2 : f1 + b [ j ][ 0 ]; } s1 += f1 + k1 * b [ j ][ 0 ]; } } for ( int j = 0 ; j < n ; j ++ ) { if ( ! y [ j ][ 1 ]) { k2 -- ; s1 += b [ j ][ 1 ]; s2 += f3 + k2 * b [ j ][ 1 ]; } } return sf2 + ( s1 < s2 ? s2 : s1 ); } int Flowshop::BBFlow ( void ) { Sort (); MinHeap < MinHeapNode > H ( 1000 ); MinHeapNode E ; E . Init ( n ); while ( E . s <= n ) { if ( E . s == n ) { if ( E . sf2 < bestc ) { bestc = E . sf2 ; for ( int i = 0 ; i < n ; i ++ ) bestx [ i ] = E . x [ i ]; } delete [] E . x ; } else { for ( int i = E . s ; i < n ; i ++ ) { Swap ( E . x [ E . s ], E . x [ i ]); int f1 , f2 ; int bb = Bound ( E , f1 , f2 , y ); if ( bb < bestc ) { MinHeapNode N ; N . NewNode ( E , f1 , f2 , bb , n ); H . Insert ( N ); } Swap ( E . x [ E . s ], E . x [ i ]); } delete [] E . x ; } try { H . DeleteMin ( E ); } catch ( OutOfBounds ) { break ; } } return bestc ; }","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"6/","text":"\u968f\u673a\u7b97\u6cd5 \u00b6 \u968f\u673a\u6570 \u6570\u503c\u968f\u673a\u5316\u7b97\u6cd5 \u820d\u4f0d\u5fb7\u7b97\u6cd5 \u62c9\u65af\u7ef4\u52a0\u65af\u7b97\u6cd5 \u8499\u7279\u5361\u7f57\u7b97\u6cd5","title":"\u968f\u673a\u7b97\u6cd5"},{"location":"6/#_1","text":"\u968f\u673a\u6570 \u6570\u503c\u968f\u673a\u5316\u7b97\u6cd5 \u820d\u4f0d\u5fb7\u7b97\u6cd5 \u62c9\u65af\u7ef4\u52a0\u65af\u7b97\u6cd5 \u8499\u7279\u5361\u7f57\u7b97\u6cd5","title":"\u968f\u673a\u7b97\u6cd5"},{"location":"6/1/","text":"","title":"\u968f\u673a\u6570"},{"location":"6/2/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6570\u503c\u968f\u673a\u5316\u7b97\u6cd5"},{"location":"6/2/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"6/3/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u820d\u4f0d\u5fb7\u7b97\u6cd5"},{"location":"6/3/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"6/4/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u62c9\u65af\u7ef4\u52a0\u65af\u7b97\u6cd5"},{"location":"6/4/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"6/5/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u8499\u7279\u5361\u7f57\u7b97\u6cd5"},{"location":"6/5/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"7/","text":"\u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41 \u00b6 \u7ebf\u6027\u89c4\u5212\u95ee\u9898\u548c\u5355\u7eaf\u5f62\u6cd5\u7b97\u6cd5 \u6700\u5927\u7f51\u7edc\u6d41\u95ee\u9898 \u6700\u5c0f\u8d39\u7528\u6d41\u95ee\u9898","title":"\u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41"},{"location":"7/#_1","text":"\u7ebf\u6027\u89c4\u5212\u95ee\u9898\u548c\u5355\u7eaf\u5f62\u6cd5\u7b97\u6cd5 \u6700\u5927\u7f51\u7edc\u6d41\u95ee\u9898 \u6700\u5c0f\u8d39\u7528\u6d41\u95ee\u9898","title":"\u7ebf\u6027\u89c4\u5212\u4e0e\u7f51\u7edc\u6d41"},{"location":"7/1/","text":"","title":"\u7ebf\u6027\u89c4\u5212\u95ee\u9898\u548c\u5355\u7eaf\u5f62\u6cd5\u7b97\u6cd5"},{"location":"7/2/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6700\u5927\u7f51\u7edc\u6d41\u95ee\u9898"},{"location":"7/2/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"7/3/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u6700\u5c0f\u8d39\u7528\u6d41\u95ee\u9898"},{"location":"7/3/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"8/","text":"\u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5 \u00b6 \u5b50\u4e32\u641c\u7d22\u7b97\u6cd5 \u540e\u7f00\u6570\u7ec4\u4e0e\u6700\u957f\u516c\u5171\u5b50\u4e32 \u5e8f\u5217\u6bd4\u8f83\u7b97\u6cd5","title":"\u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5"},{"location":"8/#_1","text":"\u5b50\u4e32\u641c\u7d22\u7b97\u6cd5 \u540e\u7f00\u6570\u7ec4\u4e0e\u6700\u957f\u516c\u5171\u5b50\u4e32 \u5e8f\u5217\u6bd4\u8f83\u7b97\u6cd5","title":"\u4e32\u4e0e\u5e8f\u5217\u7b97\u6cd5"},{"location":"8/1/","text":"","title":"\u5b50\u4e32\u641c\u7d22\u7b97\u6cd5"},{"location":"8/2/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u540e\u7f00\u6570\u7ec4\u4e0e\u6700\u957f\u516c\u5171\u5b50\u4e32"},{"location":"8/2/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"},{"location":"8/3/","text":"\u4e8c\u5206\u641c\u7d22 \u00b6","title":"\u5e8f\u5217\u6bd4\u8f83\u7b97\u6cd5"},{"location":"8/3/#_1","text":"","title":"\u4e8c\u5206\u641c\u7d22"}]}